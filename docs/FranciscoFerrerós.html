<!DOCTYPE HTML>
<!--
	Helios by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>Code - Francisco Ferrerós</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<link rel="stylesheet" href="assets/css/personal.css" />
	<noscript>
		<link rel="stylesheet" href="assets/css/noscript.css" />
	</noscript>
	<link rel="shortcut icon" type="image/png" href="images/icons/favicon.png">
</head>

<body style="align-items: center;">
	<div>

		<!-- Header -->
		<div id="header">

			<!-- Inner -->
			<header>
				<video autoplay muted loop id="video-background"
					style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;">
					<source src="images/videos/banner.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video>
				<div id="video-overlay"
					style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 2;">
				</div>
			</header>


			<!-- Nav -->
			<nav id="nav" style="z-index: 20;">
				<ul>
					<li><a href="index.html">Home</a></li>
					<li>
						<a href="teams.html">Teams</a>
						<ul>
							<li><a href="ArtTeam.html">Art</a></li>
							<li><a href="CodeTeam.html">Code</a></li>
							<li><a href="DesignTeam.html">Design</a></li>
							<li><a href="LeadsTeam.html">Leads</a></li>
						</ul>
					</li>
					<li><a href="engine.html">Engine</a></li>
					<li><a href="production.html">Production</a></li>
					<li><a href="postmortem.html">Post-Mortem</a></li>
					<li><a href="https://github.com/Shadow-Wizard-Games/TheOneEngine" target="_blank">Source Code</a>
					</li>
				</ul>
			</nav>
		</div>

		<!-- Main -->
		<div class="bio-body">
            <div class="bio-container">
                <h1 class="bio-name">Francisco Ferrerós</h1>
                <img src="images/members/code/kiko.png" alt="Profile Picture" class="bio-profile-pic">
                <p class="bio-description">
                    Currently an undergraduate student at CITM Barcelona - UPC, pursuing a degree in Video Game Design and Development, 
					passionate to begin my journey into game development.
                </p>
                <div class="member-links">
					<a href="https://github.com/JanNetoLlorens" target="_blank" class="link-icon"><i
							class="fab fa-github"></i></a>
					<a href="https://www.linkedin.com/in/jan-neto-llorens-14b511312/" target="_blank"
						class="link-icon"><i class="fab fa-linkedin"></i></a>
				</div>
            </div>
        </div>
        <hr />
      
        <div style="display: flex; justify-content: center; padding-top: 20px; align-items: center; flex-direction: column;">
            <div>
                <div>
                    <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center;">Background</h2>
                    <h3 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; text-align: center; font-size: 32px;">
                        About Me
                    </h3>
                    <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 80px; padding-right: 80px; text-align: center; font-size: 24px;">
                        I’ve always loved sharing my creativity with others. From a young age, I’ve been artistic, playing the guitar and studying classical arts in my free time.
						<br>
						<br>
						As I grew older, I tried to earn money to buy myself my first PC. I really enjoyed building it myself and decided to 
						try Computer Engineering, but it wasn’t the right fit for me.
						<br>
						<br>
						However, there I discovered programming and became passionate about it. This led me to enroll 
						in the Video Game Design and Development path, where I could embrace my creativity once again.
					</p>
                </div>
                <hr />
                <div style="display:block; align-items: center; justify-content: center;">
                    <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center; padding-top: 20px;">Project Overview</h2>
                    <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 60px; padding-right: 60px; text-align: center; font-size: 24px; padding-top: 20px;">
                        At Alien Nemesis, I was a member of the code Team. As one of the coders, I worked to develop both the Engine and the Game itself.
                    </p>
                    <h3 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; font-size: 32px; text-align: center;">
                        Main Tasks
                    </h3>
                    <div style="display:flex; flex-direction: row; justify-content: center; flex-wrap: wrap;">
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">
                            Engine Gameobject Components</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 22px;">
							My first task was helping on the refactor of the transform component. And later on assumed the task of building the basis for the UI.
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">
                            Game Interactions</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 22px;">
							I’ve been in charge of developing the player's interactions within the world.
						</p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">
                            Serialized Game Data Managing</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 22px; padding-bottom: 36px;">
                            Created the data saving and loading for the game as with the game asset data files.
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">
                            Continuity</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 22px;">
                            I assumed the responsibility of deciding how the game loop was implemented and created the game managers, in charge of the game progress.
                        </p>
						
                        </div>
						<div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">
                            Leading</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 22px;">
                            In charge of a small development group for the UI and gameplay. Also assumed the Scrum Master role several times.
                        </p>
                       
                        </div>
                    </div>
                </div>
                <hr>
				<h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center;">Work Demos</h2>
				<div style="display:flex; flex-direction: row; justify-content: center; flex-wrap: wrap;">
					<!-- Slideshow container -->
					<div class="slideshow-container" id="slideshow1" style="width: 60%;">
						<h4 style="font-family: Alien Invader; color: white; padding-top: 36px; padding-bottom: 20px; color: rgb(242, 250, 169); font-size: 24px; text-align: center;">
							Game Interactions</h4>
						<!-- Full-width images with number and caption text -->
						<div class="weaponassets fade">
							<div class="numbertext">1 / 3</div>
							<div class="model-viewer-container">
								<img src="images/bio/Jan/AdrenalineRush.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
							</div>
							<div style="display: flex; flex-direction: row; justify-content: center;">
								<div class="text">Collectibles</div>
							</div>
							
						</div>
						<div class="weaponassets fade">
							<div class="numbertext">2 / 3</div>
							<div class="model-viewer-container">
								<img src="images/bio/Kiko/Popups.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
							</div>
							<div style="display: flex; flex-direction: row; justify-content: center;">
								<div class="text">Popups</div>
							</div>
							
						</div>
						<div class="weaponassets fade">
							<div class="numbertext">3 / 3</div>
							<div class="model-viewer-container">
								<img src="images/bio/Jan/GrenadeLauncher.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
							</div>
							<div style="display: flex; flex-direction: row; justify-content: center;">
								<div class="text">Dialogue & NPC's</div>
							</div>
							
						</div>
					
						<!-- Next and previous buttons -->
						<div style="display: flex; flex-direction: row; justify-content: space-between;">
							<a class="prev" onclick="plusSlides('slideshow1', -1)">&#10094;</a>
							<a class="next" onclick="plusSlides('slideshow1', 1)">&#10095;</a>
						</div>
						
					</div>
					<!-- Slideshow container -->
					<div class="slideshow-container" id="slideshow2" style="width: 60%;">
						<h4 style="font-family: Alien Invader; color: white; padding-top: 36px; padding-bottom: 20px; color: rgb(242, 250, 169); font-size: 24px; text-align: center;">
							Gameplay</h4>
						<!-- Full-width images with number and caption text -->
						<div class="weaponassets fade">
							<div class="numbertext">1 / 3</div>
							<div class="model-viewer-container">
								<img src="images/bio/Kiko/Quests.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
							</div>
							<div style="display: flex; flex-direction: row; justify-content: center;">
								<div class="text">Questing</div>
							</div>
							
						</div>
						<div class="weaponassets fade">
							<div class="numbertext">2 / 3</div>
							<div class="model-viewer-container">
								<img src="images/bio/Kiko/Popups.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
							</div>
							<div style="display: flex; flex-direction: row; justify-content: center;">
								<div class="text">Game Intro</div>
							</div>
							
						</div>
						<div class="weaponassets fade">
							<div class="numbertext">3 / 3</div>
							<div class="model-viewer-container">
								<img src="images/bio/Kiko/GameLoad.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
							</div>
							<div style="display: flex; flex-direction: row; justify-content: center;">
								<div class="text">Game Progress Save</div>
							</div>
							
						</div>
					
						<!-- Next and previous buttons -->
						<div style="display: flex; flex-direction: row; justify-content: space-between;">
							<a class="prev" onclick="plusSlides('slideshow2', -1)">&#10094;</a>
							<a class="next" onclick="plusSlides('slideshow2', 1)">&#10095;</a>
						</div>
						
					</div>
						</div>
            </div>
        </div>  
        <hr>
        
        
            
		<!-- Footer -->
		<div id="footer">
			<div class="container">

				<div class="row">
					<div class="col-12">

						<!-- Contact -->
						<section class="contact">
							<header>
								<h3 style="color: rgb(0, 255, 0);">Want more?</h3>
							</header>
							<p style="color: white;">Check us out below!</p>
							<ul class="icons">
								<li><a href="https://x.com/ShadowWizGames" target="_blank"
										class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>

								<li><a href="https://www.instagram.com/shadow.wizard.games/" target="_blank"
										class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>

								<li><a href="https://shadowwizardgames.tumblr.com/" target="_blank"
										class="icon brands fa-tumblr"><span class="label">Tumblr</span></a>
								</li>
								<li><a href="mailto:shadow.wizard.m.games@gmail.com" class="icon fa-envelope"><span
											class="label">Email</span></a>
							</ul>
						</section>

						<!-- Copyright -->
						<div class="copyright">
							<ul class="menu">
								<li>&copy; Alien: Nemesis - Shadow Wizard Games. All rights reserved.</li>
							</ul>
						</div>
					</div>

				</div>
			</div>
		</div>

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/jquery.dropotron.min.js"></script>
	<script src="assets/js/jquery.scrolly.min.js"></script>
	<script src="assets/js/jquery.scrollex.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>
	<script src="assets/js/Code.js"></script>
	<script src="assets/js/playbuttondelay.js"></script>
    <script>
        function openTab(evt, tabName) {
            // Declare all variables
            var i, tabcontent, tablinks;
    
            // Get all elements with class="bio-tab-content" and hide them
            tabcontent = document.getElementsByClassName("bio-tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove('active');
            }
    
            // Get all elements with class="bio-tab" and remove the class "active"
            tablinks = document.getElementsByClassName("bio-tab");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
    
            // Show the current tab, and add an "active" class to the button that opened the tab
            document.getElementById(tabName).style.display = "block";
            document.getElementById(tabName).classList.add('active');
            evt.currentTarget.className += " active";
        }
    </script>
    <script>
                        // Define an object to store slide indexes for each slideshow
            let slideIndexes = {};

            // Initialize slide indexes for each slideshow
            function initSlideIndexes() {
                let slideshowContainers = document.querySelectorAll('.slideshow-container');
                slideshowContainers.forEach((container, index) => {
                    slideIndexes['slideshow' + (index + 1)] = 1; // Initialize slide index to 1 for each slideshow
                });
            }

            function showSlides(slideshowIndex, n) {
                let slides = document.querySelectorAll('#' + slideshowIndex + ' .weaponassets');
                if (n > slides.length) { slideIndexes[slideshowIndex] = 1; }
                if (n < 1) { slideIndexes[slideshowIndex] = slides.length; }
                slides.forEach((slide, index) => {
                    slide.style.display = "none";
                });
                slides[slideIndexes[slideshowIndex] - 1].style.display = "block";

                // Update the slide index text
                let slideIndexText = document.querySelector('#' + slideshowIndex + ' .numbertext');
                if (slideIndexText) {
                    slideIndexText.textContent = slideIndexes[slideshowIndex] + ' / ' + slides.length;
                }
            }

            // Change slide for a specific slideshow
            function plusSlides(slideshowIndex, n) {
                showSlides(slideshowIndex, slideIndexes[slideshowIndex] += n);
            }

            // Set up slide indexes for all slideshows
            initSlideIndexes();

            // Show the initial slides for all slideshows
            Object.keys(slideIndexes).forEach(slideshowIndex => {
                showSlides(slideshowIndex, slideIndexes[slideshowIndex]);
            });
    </script>

</body>

</html>

<script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.5.0/model-viewer.min.js"></script>
<!-- Monaco Editor -->
<script src="https://cdn.jsdelivr.net/npm/monaco-editor/min/vs/loader.js"></script>
<script>
    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor/min/vs' }});
    require(['vs/editor/editor.main'], function() {
        function createEditor(id, value, language) {
            const container = document.getElementById(id);
            const editor = monaco.editor.create(container, {
                value: value,
                language: language,
                theme: 'vs-dark',
                readOnly: true // Set editor to read-only
            });

            // Inject CSS rules to round the corners of the editor
            const styleElement = document.createElement('style');
            styleElement.innerHTML = `
                .monaco-editor .overflow-guard,
                .monaco-editor .monaco-scrollable-element {
                    border-radius: 10px;
                    overflow: hidden !important;
                    border: none !important; /* Ensure no border */
                }
            `;
            editor._domElement.appendChild(styleElement); // Append style to the editor's DOM

            // Adjust the layout to fit the container size
            function resizeEditor() {
                const containerRect = container.getBoundingClientRect();
                editor.layout({
                    width: containerRect.width,
                    height: containerRect.height
                });
            }

            // Trigger layout adjustment after editor creation and after a small delay
            resizeEditor();
            setTimeout(resizeEditor, 100); // Delay to ensure correct dimensions

            // Adjust layout on window resize
            window.addEventListener('resize', resizeEditor);
        }

        // Initialize editors
        function initializeEditors() {
        // Editor 1
        createEditor('editor1', `class InstanceCall;
class SkeletalCall;
class RenderTarget;
class ResourceId;
class GameObject;
class StackVertexArray;

class Renderer3D
{
public:
	static void Init();
	static void Update(RenderTarget target);
	static void Shutdown();

	static void ResetCalls();

	static void GeometryPass(RenderTarget target);
	static void IndexPass(RenderTarget target);
	static bool InitPostProcess(RenderTarget target);
	static void EndPostProcess(RenderTarget target);
	static void ShadowPass(RenderTarget target);
	static void LightPass(RenderTarget target);
	static void UIComposition(RenderTarget target);
	static void CRTShader(RenderTarget target);

	static void SetUniformsParticleShader(ResourceId materialID, RenderTarget target);

	static void AddLight(std::shared_ptr<GameObject> container);
	static void RemoveLight(std::shared_ptr<GameObject> container);
	static void CleanLights();
	static void ResetUniforms(LightType lightType);
	static void ResetAllUniforms();

	static void AddMesh(StackVertexArray meshID, int matID);
	static void AddMeshToQueue(StackVertexArray meshID, int matID, const glm::mat4& modelMat);
	static void AddSkeletalMeshToQueue(int meshID, int matID, const glm::mat4& modelMat, bool hasEffect = false);

	// Stats
	struct Statistics
	{
		uint32_t InstanceCalls = 0;
		uint32_t SkeletalCalls = 0;
		uint32_t MeshesInQueue = 0;
	};
	static Statistics GetStats();
	static void ResetStats();
	static int GetMeshCount();

private:
	static void AddInstanceCall(StackVertexArray meshID, int matID, const glm::mat4& modelMat);
	static void UpdateInstanceBuffer(const std::vector<InstanceCall>& calls);

	static void DrawInstanced(const InstanceCall& call);
	static void DrawSkeletal(const SkeletalCall& call, bool overrideEffects = false);

	static void InitPreLightingShader();
	static void InitPostLightingShader();
	static void InitIndexShaders();
	static void InitCRTShader();
};

`, 'cpp');

        // Editor 2
        createEditor('editor2', `#include "ParticleSystem.h"
#include "GameObject.h"
#include "SingleOrRandom.h"
#include "EngineCore.h"
#include <ostream>
#include <istream>
#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;

ParticleSystem::ParticleSystem(std::shared_ptr<GameObject> containerGO) : Component(containerGO, ComponentType::ParticleSystem)
{
	this->transform = containerGO.get()->GetComponent<Transform>();

	if (transform == nullptr)
	{
		LOG(LogType::LOG_ERROR, "GameObject Container invalid!");
	}

	startON = true;

	isON = startON;
	hasToEnd = false;
	AddEmmiter();
}

ParticleSystem::ParticleSystem(std::shared_ptr<GameObject> containerGO, ParticleSystem* ref) : Component(containerGO, ComponentType::ParticleSystem),
isON(ref->isON)
{
	this->transform = containerGO.get()->GetComponent<Transform>();

	if (transform == nullptr)
	{
		LOG(LogType::LOG_ERROR, "GameObject Container invalid!");
	}

	for (const auto& emmiter : ref->emmiters) {
		AddEmmiter(emmiter.get());
	}

	startON = ref->startON;

	isON = startON;
	hasToEnd = false;
}

ParticleSystem::~ParticleSystem()
{
}

void ParticleSystem::Update(double dt)
{
	bool allEmmitersOFF = true;

	if (isON) {
		for (auto i = emmiters.begin(); i != emmiters.end(); ++i) {
			(*i)->Update(engine->dt);

			if ((*i)->isON) {
				allEmmitersOFF = false;
			}
		}

		if (allEmmitersOFF) {
			Stop();
		}
	}
}

void ParticleSystem::DrawComponent(Camera* camera)
{
	for (auto i = emmiters.begin(); i != emmiters.end(); ++i) {
		(*i)->Render(camera);
	}
}

void ParticleSystem::Play()
{
	isON = true;
	hasToEnd = false;
}

void ParticleSystem::Pause()
{
	isON = false;
}

void ParticleSystem::Replay()
{
	Play();
	for (auto i = emmiters.begin(); i != emmiters.end(); ++i) {
		(*i)->Start();
	}
	hasToEnd = false;
}

void ParticleSystem::Stop()
{
	Pause();
	for (auto i = emmiters.begin(); i != emmiters.end(); ++i) {
		(*i)->Start();
	}
}

void ParticleSystem::End()
{
	hasToEnd = true;
}

bool ParticleSystem::HasToEnd()
{
	return hasToEnd;
}

void ParticleSystem::ClearEmmiters()
{
	emmiters.clear();
}

Emmiter* ParticleSystem::AddEmmiter()
{
	auto e = std::make_unique<Emmiter>(this);
	emmiters.push_back(std::move(e));
	return emmiters[emmiters.size() - 1].get();
}

Emmiter* ParticleSystem::AddEmmiter(Emmiter* ref)
{
	auto e = std::make_unique<Emmiter>(this, ref);
	emmiters.push_back(std::move(e));
	return emmiters[emmiters.size() - 1].get();
}

json ParticleSystem::SaveComponent()
{
	json particleSystemJSON;

	if (!emmiters.empty())
	{
		json emmitersJSON;

		for (const auto& emmiter : emmiters)
		{
			emmitersJSON.push_back(emmiter.get()->SaveEmmiter());
		}
		particleSystemJSON["Emmiters"] = emmitersJSON;
	}

	particleSystemJSON["UID"] = UID;
	particleSystemJSON["Name"] = name;
	particleSystemJSON["Type"] = type;

	particleSystemJSON["StartON"] = startON;

	return particleSystemJSON;
}

void ParticleSystem::LoadComponent(const json& transformJSON)
{
	// Load basic properties
	if (transformJSON.contains("UID"))
	{
		UID = transformJSON["UID"];
	}

	if (transformJSON.contains("Name"))
	{
		name = transformJSON["Name"];
	}

	if (transformJSON.contains("Type"))
	{
		type = transformJSON["Type"];
	}

	if (transformJSON.contains("StartON"))
	{
		startON = transformJSON["StartON"];
		isON = startON;
	}

	ClearEmmiters();

	// load emmiters
	if (transformJSON.contains("Emmiters"))
	{
		const json& emmitersJSON = transformJSON["Emmiters"];

		for (const auto& emmiterJSON : emmitersJSON)
		{
			auto e = AddEmmiter();
			e->ClearModules();
			e->LoadEmmiter(emmiterJSON);
		}
	}

}

void ParticleSystem::ExportParticles()
{
	//Change to save the Scene Class
	name.shrink_to_fit();
	std::string fileNameExt = name;

	std::string finalName;

	for (int i = 0; fileNameExt.at(i) != '\0'; ++i) {
		finalName += fileNameExt.at(i);
	}

	name = finalName;

	finalName.append(".particles");

	fs::path filename = fs::path(ASSETS_PATH) / "Particles" / finalName;
	//string filename = "Assets/Scenes/";
	fs::path folderName = fs::path(ASSETS_PATH) / "Particles";
	fs::create_directories(folderName);

	json particlesJSON;

	particlesJSON = SaveComponent();

	std::ofstream(filename) << particlesJSON.dump(2);
	LOG(LogType::LOG_OK, "SAVE SUCCESFUL");
}

bool ParticleSystem::IsON()
{
	return isON;
}

Transform* ParticleSystem::GetTransform()
{
	return transform;
}`, 'cpp');

        // Editor 3
        createEditor('editor3', `#include "InitializeEmmiterModule.h"
#include "Emmiter.h"
#include "ParticleSystem.h"

// set speed ---------------------------------------------------------------------------------------------------
SetSpeed::SetSpeed(Emmiter* owner)
{
	type = SET_SPEED;
	this->owner = owner;

	speed.usingSingleValue = false;
	speed.rangeValue.lowerLimit = 1;
	speed.rangeValue.upperLimit = 2;
}

SetSpeed::SetSpeed(Emmiter* owner, SetSpeed* ref)
{
	type = SET_SPEED;
	this->owner = owner;

	speed = ref->speed;
}

void SetSpeed::Initialize(Particle* particle)
{
	if (speed.usingSingleValue) {
		particle->speed = speed.singleValue;
	}
	else {
		particle->speed = randomFloat(speed.rangeValue.lowerLimit, speed.rangeValue.upperLimit);
	}
}

json SetSpeed::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueSpeed"] = speed.usingSingleValue;
	moduleJSON["MinSpeed"] = speed.rangeValue.lowerLimit;
	moduleJSON["MaxSpeed"] = speed.rangeValue.upperLimit;

	return moduleJSON;
}

void SetSpeed::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueSpeed"))
	{
		speed.usingSingleValue = moduleJSON["UsingSingleValueSpeed"];
	}

	if (moduleJSON.contains("MinSpeed"))
	{
		speed.rangeValue.lowerLimit = moduleJSON["MinSpeed"];
	}

	if (moduleJSON.contains("MaxSpeed"))
	{
		speed.rangeValue.upperLimit = moduleJSON["MaxSpeed"];
	}
}

// set color ---------------------------------------------------------------------------------------------------
SetColor::SetColor(Emmiter* owner)
{
	type = SET_COLOR;
	this->owner = owner;

	color.usingSingleValue = true;
	color.rangeValue.lowerLimit = glm::vec4(0, 0, 0, 1);
	color.rangeValue.upperLimit = glm::vec4(1, 1, 1, 0);
}

SetColor::SetColor(Emmiter* owner, SetColor* ref)
{
	type = SET_COLOR;
	this->owner = owner;

	color = ref->color;
}

void SetColor::Initialize(Particle* particle)
{
	if (color.usingSingleValue) {
		particle->initialColor = color.singleValue;
	}
	else {
		glm::vec4 randomVec = glm::vec4{
			randomFloat(color.rangeValue.lowerLimit.r, color.rangeValue.upperLimit.r),
			randomFloat(color.rangeValue.lowerLimit.g, color.rangeValue.upperLimit.g),
			randomFloat(color.rangeValue.lowerLimit.b, color.rangeValue.upperLimit.b),
			randomFloat(color.rangeValue.lowerLimit.a, color.rangeValue.upperLimit.a),
		};

		particle->initialColor = randomVec;
	}

	particle->color = particle->initialColor;
}

json SetColor::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueColor"] = color.usingSingleValue;
	moduleJSON["MinColor"] = { color.rangeValue.lowerLimit.x, color.rangeValue.lowerLimit.y, color.rangeValue.lowerLimit.z, color.rangeValue.lowerLimit.a };
	moduleJSON["MaxColor"] = { color.rangeValue.upperLimit.x, color.rangeValue.upperLimit.y, color.rangeValue.upperLimit.z, color.rangeValue.upperLimit.a };

	return moduleJSON;
}

void SetColor::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueColor"))
	{
		color.usingSingleValue = moduleJSON["UsingSingleValueColor"];
	}

	if (moduleJSON.contains("MinColor"))
	{
		color.rangeValue.lowerLimit.x = moduleJSON["MinColor"][0];
		if (color.rangeValue.lowerLimit.x > 1)
			color.rangeValue.lowerLimit.x /= 255;
		color.rangeValue.lowerLimit.y = moduleJSON["MinColor"][1];
		if (color.rangeValue.lowerLimit.y > 1)
			color.rangeValue.lowerLimit.y /= 255;
		color.rangeValue.lowerLimit.z = moduleJSON["MinColor"][2];
		if (color.rangeValue.lowerLimit.z > 1)
			color.rangeValue.lowerLimit.z /= 255;
		color.rangeValue.lowerLimit.a = moduleJSON["MinColor"][3];
		if (color.rangeValue.lowerLimit.a > 1) 
			color.rangeValue.lowerLimit.a /= 255;
	}

	if (moduleJSON.contains("MaxColor"))
	{
		color.rangeValue.upperLimit.x = moduleJSON["MaxColor"][0];
		if (color.rangeValue.upperLimit.x > 1)
			color.rangeValue.upperLimit.x /= 255;
		color.rangeValue.upperLimit.y = moduleJSON["MaxColor"][1];
		if (color.rangeValue.upperLimit.y > 1)
			color.rangeValue.upperLimit.y /= 255;
		color.rangeValue.upperLimit.z = moduleJSON["MaxColor"][2];
		if (color.rangeValue.upperLimit.z > 1) 
			color.rangeValue.upperLimit.z /= 255;
		color.rangeValue.upperLimit.a = moduleJSON["MaxColor"][3];
		if (color.rangeValue.upperLimit.a > 1)
			color.rangeValue.upperLimit.a /= 255;
	}
}

// set scale ---------------------------------------------------------------------------------------------------
SetScale::SetScale(Emmiter* owner)
{
	type = SET_SCALE;
	this->owner = owner;

	scale.usingSingleValue = true;
	scale.rangeValue.lowerLimit = vec3(1, 1, 1);
	scale.rangeValue.upperLimit = vec3(2, 2, 2);

	isProportional = true;
}

SetScale::SetScale(Emmiter* owner, SetScale* ref)
{
	type = SET_SCALE;
	this->owner = owner;

	scale = ref->scale;
	isProportional = ref->isProportional;
}

void SetScale::Initialize(Particle* particle)
{
	if (scale.usingSingleValue) {
		if (isProportional) {
			particle->initialScale = vec3(scale.singleValue.x, scale.singleValue.x, scale.singleValue.x);
		}
		else {
			particle->initialScale = scale.singleValue;
		}
	}
	else {
		vec3 randomVec;
		if (isProportional) {
			auto value = randomFloat(scale.rangeValue.lowerLimit.x, scale.rangeValue.upperLimit.x);
			randomVec = vec3(value, value, value);
		}
		else {
			randomVec = vec3{
				randomFloat(scale.rangeValue.lowerLimit.x, scale.rangeValue.upperLimit.x),
				randomFloat(scale.rangeValue.lowerLimit.y, scale.rangeValue.upperLimit.y),
				randomFloat(scale.rangeValue.lowerLimit.z, scale.rangeValue.upperLimit.z) };
		}
		particle->initialScale = randomVec;
	}

	particle->scale = particle->initialScale;
}

json SetScale::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueScale"] = scale.usingSingleValue;
	moduleJSON["MinScale"] = { scale.rangeValue.lowerLimit.x, scale.rangeValue.lowerLimit.y, scale.rangeValue.lowerLimit.z };
	moduleJSON["MaxScale"] = { scale.rangeValue.upperLimit.x, scale.rangeValue.upperLimit.y, scale.rangeValue.upperLimit.z };

	moduleJSON["IsProportional"] = isProportional;

	return moduleJSON;
}

void SetScale::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueScale"))
	{
		scale.usingSingleValue = moduleJSON["UsingSingleValueScale"];
	}

	if (moduleJSON.contains("MinScale"))
	{
		scale.rangeValue.lowerLimit.x = moduleJSON["MinScale"][0];
		scale.rangeValue.lowerLimit.y = moduleJSON["MinScale"][1];
		scale.rangeValue.lowerLimit.z = moduleJSON["MinScale"][2];

	}

	if (moduleJSON.contains("MaxScale"))
	{
		scale.rangeValue.upperLimit.x = moduleJSON["MaxScale"][0];
		scale.rangeValue.upperLimit.y = moduleJSON["MaxScale"][1];
		scale.rangeValue.upperLimit.z = moduleJSON["MaxScale"][2];
	}

	if (moduleJSON.contains("IsProportional"))
	{
		isProportional = moduleJSON["IsProportional"];
	}
}

// set offset --------------------------------------------------------------------------------------
SetOffset::SetOffset(Emmiter* owner)
{
	type = SET_OFFSET;
	this->owner = owner;

	offset.usingSingleValue = true;
	offset.rangeValue.lowerLimit = vec3(0, 1, 0);
	offset.rangeValue.upperLimit = vec3(0, -1, 0);
}

SetOffset::SetOffset(Emmiter* owner, SetOffset* ref)
{
	type = SET_OFFSET;
	this->owner = owner;

	offset = ref->offset;
}

void SetOffset::Initialize(Particle* particle)
{
	if (offset.usingSingleValue) {
		particle->position += offset.singleValue;
	}
	else {
		vec3 randomVec = vec3{
			randomFloat(offset.rangeValue.lowerLimit.x, offset.rangeValue.upperLimit.x),
			randomFloat(offset.rangeValue.lowerLimit.y, offset.rangeValue.upperLimit.y),
			randomFloat(offset.rangeValue.lowerLimit.z, offset.rangeValue.upperLimit.z) };

		quat qTemp = owner->owner->GetContainerGO()->GetComponent<Transform>()->GetGlobalRotation();
		particle->position += randomVec * quat(-qTemp.x, qTemp.y, qTemp.z, qTemp.w);
	}
}

json SetOffset::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueOffset"] = offset.usingSingleValue;
	moduleJSON["MinOffset"] = { offset.rangeValue.lowerLimit.x, offset.rangeValue.lowerLimit.y, offset.rangeValue.lowerLimit.z };
	moduleJSON["MaxOffset"] = { offset.rangeValue.upperLimit.x, offset.rangeValue.upperLimit.y, offset.rangeValue.upperLimit.z };

	return moduleJSON;
}

void SetOffset::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueOffset"))
	{
		offset.usingSingleValue = moduleJSON["UsingSingleValueOffset"];
	}

	if (moduleJSON.contains("MinOffset"))
	{
		offset.rangeValue.lowerLimit.x = moduleJSON["MinOffset"][0];
		offset.rangeValue.lowerLimit.y = moduleJSON["MinOffset"][1];
		offset.rangeValue.lowerLimit.z = moduleJSON["MinOffset"][2];

	}

	if (moduleJSON.contains("MaxOffset"))
	{
		offset.rangeValue.upperLimit.x = moduleJSON["MaxOffset"][0];
		offset.rangeValue.upperLimit.y = moduleJSON["MaxOffset"][1];
		offset.rangeValue.upperLimit.z = moduleJSON["MaxOffset"][2];
	}
}

// set direction -----------------------------------------------------------------------------------
SetDirection::SetDirection(Emmiter* owner)
{
	type = SET_DIRECTION;
	this->owner = owner;

	direction.usingSingleValue = false;
	direction.rangeValue.lowerLimit = vec3(-0.5f, 1, -0.5f);
	direction.rangeValue.upperLimit = vec3(0.5f, 2, 0.5f);
}

SetDirection::SetDirection(Emmiter* owner, SetDirection* ref)
{
	type = SET_DIRECTION;
	this->owner = owner;

	direction = ref->direction;

}

void SetDirection::Initialize(Particle* particle)
{
	if (direction.usingSingleValue) {
		particle->direction = direction.singleValue;
	}
	else {
		vec3 randomVec = vec3{
			randomFloat(direction.rangeValue.lowerLimit.x, direction.rangeValue.upperLimit.x),
			randomFloat(direction.rangeValue.lowerLimit.y, direction.rangeValue.upperLimit.y),
			randomFloat(direction.rangeValue.lowerLimit.z, direction.rangeValue.upperLimit.z) };

		particle->direction = randomVec;
	}

	if (owner->isGlobal) {
		mat4 worldTransform = owner->owner->GetTransform()->GetGlobalTransform();

		glm::dmat3 worldRotation = worldTransform;
		
		particle->direction = worldRotation * particle->direction;
	}

	if(particle->direction != vec3())
		particle->direction = glm::normalize(particle->direction);
}

json SetDirection::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueDirection"] = direction.usingSingleValue;
	moduleJSON["MinDirection"] = { direction.rangeValue.lowerLimit.x, direction.rangeValue.lowerLimit.y, direction.rangeValue.lowerLimit.z };
	moduleJSON["MaxDirection"] = { direction.rangeValue.upperLimit.x, direction.rangeValue.upperLimit.y, direction.rangeValue.upperLimit.z };

	return moduleJSON;
}

void SetDirection::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueDirection"))
	{
		direction.usingSingleValue = moduleJSON["UsingSingleValueDirection"];
	}

	if (moduleJSON.contains("MinDirection"))
	{
		direction.rangeValue.lowerLimit.x = moduleJSON["MinDirection"][0];
		direction.rangeValue.lowerLimit.y = moduleJSON["MinDirection"][1];
		direction.rangeValue.lowerLimit.z = moduleJSON["MinDirection"][2];

	}

	if (moduleJSON.contains("MaxDirection"))
	{
		direction.rangeValue.upperLimit.x = moduleJSON["MaxDirection"][0];
		direction.rangeValue.upperLimit.y = moduleJSON["MaxDirection"][1];
		direction.rangeValue.upperLimit.z = moduleJSON["MaxDirection"][2];
	}
}`, 'cpp'); 

createEditor('editor4' ,`using System;
using System.Runtime.CompilerServices;

public struct Vector3
{
    public float x { get; }
    public float y { get; }
    public float z { get; }

    public static Vector3 zero      { get { return new Vector3(0, 0, 0); } }
    public static Vector3 right     { get { return new Vector3(1.0f, 0, 0); } }
    public static Vector3 up        { get { return new Vector3(0, 1.0f, 0); } }
    public static Vector3 forward   { get { return new Vector3(0, 0, 1.0f); } }

    public Vector3(float x, float y, float z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public static Vector3 operator +(Vector3 a, Vector3 b)
    {
        return new Vector3(a.x + b.x, a.y + b.y, a.z + b.z);
    }

    public static Vector3 operator -(Vector3 a, Vector3 b)
    {
        return new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }

    public static Vector3 operator *(Vector3 a, Vector3 b)
    {
        return new Vector3(a.x * b.x, a.y * b.y, a.z * b.z);
    }

    public static Vector3 operator *(Vector3 a, float b)
    {
        return new Vector3(a.x * b, a.y * b, a.z * b);
    }

    public static Vector3 operator /(Vector3 a, float b)
    {
        return new Vector3(a.x / b, a.y / b, a.z / b);
    }

    public static bool operator ==(Vector3 a, Vector3 b)
    {
        return a.x == b.x && a.y == b.y && a.z == b.z;
    }

    public static bool operator !=(Vector3 a, Vector3 b)
    {
        return a.x != b.x || a.y != b.y || a.z != b.z;
    }

    public float Magnitude()
    {
        return (float)Math.Sqrt(x * x + y * y + z * z);
    }

    public Vector3 Normalize()
    {
        float mag = Magnitude();

        if (mag == 0) { return Vector3.zero; }

        return new Vector3(x, y, z) / Magnitude();
    }

    public static float Distance(Vector3 a, Vector3 b)
    {
        Vector3 resultVector = a - b;

        return resultVector.Magnitude();
    }

    public static float Dot(Vector3 a, Vector3 b)
    {
        return  -(a.x * b.x + a.y * b.y + a.z * b.z);
    }
}
` , 'cpp'); }
// Wait for the window to fully load before initializing editors
window.onload = function() {
            initializeEditors();
            setTimeout(function() {
                document.querySelectorAll('.editor-container').forEach(container => {
                    const event = new Event('resize');
                    window.dispatchEvent(event);
                });
            }, 100);
        };
    });
</script>
