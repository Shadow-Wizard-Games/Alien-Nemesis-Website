<!DOCTYPE HTML>
<!--
	Helios by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>Code - Jonathan Cacay</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<link rel="stylesheet" href="assets/css/personal.css" />
	<noscript>
		<link rel="stylesheet" href="assets/css/noscript.css" />
	</noscript>
	<link rel="shortcut icon" type="image/png" href="images/icons/favicon.png">
</head>

<body style="align-items: center;">
	<div>

		<!-- Header -->
		<div id="header">

			<!-- Inner -->
			<header>
				<video autoplay muted loop id="video-background"
					style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;">
					<source src="images/videos/banner.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video>
				<div id="video-overlay"
					style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 2;">
				</div>
			</header>


			<!-- Nav -->
			<nav id="nav" style="z-index: 20;">
				<ul>
					<li><a href="index.html">Home</a></li>
					<li>
						<a href="teams.html">Teams</a>
						<ul>
							<li><a href="ArtTeam.html">Art</a></li>
							<li><a href="CodeTeam.html">Code</a></li>
							<li><a href="DesignTeam.html">Design</a></li>
							<li><a href="LeadsTeam.html">Leads</a></li>
						</ul>
					</li>
					<li><a href="engine.html">Engine</a></li>
					<li><a href="production.html">Production</a></li>
					<li><a href="postmortem.html">Post-Mortem</a></li>
					<li><a href="https://github.com/Shadow-Wizard-Games/TheOneEngine" target="_blank">Source Code</a>
					</li>
				</ul>
			</nav>
		</div>

		<!-- Main -->
		<div class="bio-body">
            <div class="bio-container">
                <h1 class="bio-name">Jonathan Cacay</h1>
                <img src="images/members/code/caray.png" alt="Profile Picture" class="bio-profile-pic">
                <p class="bio-description">
                    I am a dedicated student at CITM - UPC in Barcelona, 
                    Spain, currently pursuing a degree in Video Game Design & Development. 
                    Born and raised in Barcelona with Filipino heritage. Contact me if you want to create something amazing together!
                </p>
            </div>
        </div>
        <hr />
      
        <div style="display: flex; justify-content: center; padding-top: 20px; align-items: center; flex-direction: column;">
            <div>
                <div>
                    <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center;">Background</h2>
                    <h3 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; text-align: center; font-size: 32px;">
                        About Me
                    </h3>
                    <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 80px; padding-right: 80px; text-align: center; font-size: 24px;">
                        Ever since I was a kid, video games have been a constant in my life, 
                        from Pok√©mon to Final Fantasy. This lifelong passion naturally evolved into a 
                        dream of becoming a video game developer. <br><br>

                        My love for coding drives me to take on any challenge. I am fascinated by 
                        gameplay mechanics coding and strive to innovate with every project I undertake. 
                        I'm always eager to learn, grow, and push the boundaries of what is possible in game development. <br><br>

                        Some projects that I worked on in the past are: <a href="https://github.com/Ethanm-0371/Jailed-VR" class="styled-link">Jailed VR</a>, 
                        <a href="https://github.com/xGauss05/OwoGamesProject1" class="styled-link">Guerrilla War (Tribute)</a>,
                        <a href="https://github.com/xGauss05/RPG-Game-Project" class="styled-link">Return JRPG</a>,
                        <a href="https://github.com/xGauss05/RaceCar" class="styled-link">Race Car</a>,
                        <a href="https://github.com/xGauss05/PlatformerGame" class="styled-link">Super Metal Boy</a>,
                        <a href="https://xgauss05.itch.io/no-time-to-dice" class="styled-link">No Time to Di(c)e</a>, and
                        <a href="https://xgauss05.itch.io/lost-in-dreams" class="styled-link">Lost in Dreams</a>

                    </p>
                </div>
                <hr />
                <div style="display:block; align-items: center; justify-content: center;">
                    <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center; padding-top: 20px;">Project Overview</h2>
                    <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 60px; padding-right: 60px; text-align: center; font-size: 24px; padding-top: 20px;">
                        In this project, I was responsible for keeping the game Builder working seamlessly. 
                        I also coded the logic for the Item Manager and developed the behavior and animations for various Also I have been 
                        working in the Scripting Engine by adding certain Internal Calls in order to be able to do the Enemy Behaviors. And overall, 
                        I was aiding my colleagues in bug fixing.
                    </p>
                    <h3 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; font-size: 32px; text-align: center;">
                        Main Tasks
                    </h3>
                    <div style="display:flex; flex-direction: row; justify-content: center; flex-wrap: wrap;">
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <div style="display:flex; flex-direction: row;">
                            <img src="images/bio/Jonathan/Builder (1).png" style="object-fit: cover; height:400px; border-radius: 5%;" alt="" />
                            <div style="display:flex; flex-direction: column; align-items:right;">
                                <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: right;">TheOneBuilder</h4>
                                <p style="padding: 0px 0px 0 0; text-align: center; color: white; font-size: 22px; text-align: right; padding-left: 20px;">I created a new project that acted as another entry point for the engine and removed all the editor aspects of TheOneEditor to build the .exe file.
                            </p>
                            </div>
                        </div>
                        
                        
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Item Manager</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 22px;">
                            I designed the logic of the ItemManager by creating dictionaries to save the items by unique IDs. 
                        </p>
                        <img src="images/bio/Jonathan/ItemManager.png" style="object-fit: cover; height:200px;" alt="" />
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Enemies Behaviors & Animations</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 22px;">
                            By following the guidelines given by the design team, I coded all the behaviors for the normal enemies.
                        </p>
                        <img src="images/bio/Jonathan/EnemyBehavior.png" style="object-fit: cover; height:200px;" alt="" />
                        </div>
                    </div>
                </div>
                <hr>
                <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center; padding-top: 20px; padding-bottom: 40px;">Work Demos</h2>
                    <div style="display:flex; flex-direction: row; justify-content: center; flex-wrap: wrap;">
                        <!-- Slideshow container -->
                        <div class="slideshow-container" id="slideshow1" style="width: 800px;">
                            <h4 style="font-family: Alien Invader; color: white; padding-top: 36px; padding-bottom: 20px; color: rgb(242, 250, 169); font-size: 24px; text-align: center;">
                                Enemy Behaviors & Animations</h4>
                            <!-- Full-width images with number and caption text -->
                            <div class="weaponassets fade">
                                <div class="numbertext">1 / 6</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Jonathan/WhiteXenomorph.gif" style="object-fit: cover; border-radius: 5%; width: 760px;">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">White Xenomorph</div>
                                </div>
                                
                            </div>
                        
                            <div class="weaponassets fade">
                                <div class="numbertext">2 / 6</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Jonathan/Anarchist.gif" style="object-fit: cover; border-radius: 5%; width: 760px;">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Anarchist</div>
                                </div>
                                
                            </div>
                        
                            <div class="weaponassets fade">
                                <div class="numbertext">3 / 6</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Jonathan/Chestburster.gif" style="object-fit: cover; border-radius: 5%; width: 760px;">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Chestburster</div>
                                </div>
                                
                            </div>

                            <div class="weaponassets fade">
                                <div class="numbertext">4 / 6</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Jonathan/Facehugger.gif" style="object-fit: cover; border-radius: 5%; width: 760px;">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Facehugger</div>
                                </div>
                                
                            </div>

                            <div class="weaponassets fade">
                                <div class="numbertext">5 / 6</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Jonathan/RedXenomorph.gif" style="object-fit: cover; border-radius: 5%; width: 760px;">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Red Xenomorph</div>
                                </div>
                                
                            </div>

                            <div class="weaponassets fade">
                                <div class="numbertext">6 / 6</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Jonathan/AdultXenomorph.gif" style="object-fit: cover; border-radius: 5%; width: 760px;">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Adult Xenomorph</div>
                                </div>
                                
                            </div>
                        
                            <!-- Next and previous buttons -->
                            <div style="display: flex; flex-direction: row; justify-content: space-between;">
                                <a class="prev" onclick="plusSlides('slideshow1', -1)">&#10094;</a>
                                <a class="next" onclick="plusSlides('slideshow1', 1)">&#10095;</a>
                            </div>
                            
                        </div>
                    </div>
            </div>
        </div> 
        <hr>
        <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center; padding-top: 20px; padding-bottom: 40px;">Code Snippets</h2>
                <div style="display: flex; flex-direction: row; justify-content: space-evenly">
                    <div style="display: flex; flex-direction: column; align-items: left; justify-content: left; width: 400px;">
                    <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); font-size: 28px; text-align: left;">
                        Anarchist Behavior</h4>
                        <p style="padding: 0px 0px 0 0; color: white; font-size: 22px; text-align: left;">
                            Behavior within the game title, involving state management, detection, animations, & more. 
                        </p>
                    </div>
                    <div id="editor1" class="editor-container"></div>
                </div>
                <div style="display: flex; flex-direction: row; justify-content: space-evenly; padding-top: 80px;">
                    <div id="editor2" class="editor-container"></div>
                    <div style="display: flex; flex-direction: column; align-items: right; justify-content: right; width: 400px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); font-size: 28px; text-align: right;">
                            Chestburster Behavior</h4>
                            <p style="padding: 0px 0px 0 0; color: white; font-size: 22px; text-align: right;">Behavior within the game title, involving state management, detection, animations, & more. </p>
                        </div>
                </div>
                <div style="display: flex; flex-direction: row; justify-content: space-evenly; padding-top: 80px;">
                    <div style="display: flex; flex-direction: column; align-items: left; justify-content: left; width: 400px;">
                    <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); font-size: 28px; text-align: left;">
                        Facehugger Behavior</h4>
                        <p style="padding: 0px 0px 0 0; color: white; font-size: 22px; text-align: left;">
                            Behavior within the game title, involving state management, detection, animations, & more. 
                        </p>
                    </div>
                    <div id="editor3" class="editor-container"></div>
                </div>
                <div style="display: flex; flex-direction: row; justify-content: space-evenly; padding-top: 80px;">
                    <div id="editor4" class="editor-container"></div>
                    <div style="display: flex; flex-direction: column; align-items: right; justify-content: right; width: 400px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); font-size: 28px; text-align: right;">
                            Adult Xenomorph Behavior</h4>
                            <p style="padding: 0px 0px 0 0; color: white; font-size: 22px; text-align: right;">
                                Behavior within the game title, involving state management, detection, animations, & more. 
                            </p>
                        </div>
                </div>  
                <div style="display: flex; flex-direction: row; justify-content: space-evenly; padding-top: 80px;">
                    <div style="display: flex; flex-direction: column; align-items: left; justify-content: left; width: 400px;">
                    <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); font-size: 28px; text-align: left;">
                        Red Xenomorph Behavior</h4>
                        <p style="padding: 0px 0px 0 0; color: white; font-size: 22px; text-align: left;">
                            Behavior within the game title, involving state management, detection, animations, & more. 
                        </p>
                    </div>
                    <div id="editor5" class="editor-container"></div>
                </div>
                <div style="display: flex; flex-direction: row; justify-content: space-evenly; padding-top: 80px;">
                    <div id="editor6" class="editor-container"></div>
                    <div style="display: flex; flex-direction: column; align-items: right; justify-content: right; width: 400px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); font-size: 28px; text-align: right;">
                            White Xenomorph Behavior</h4>
                            <p style="padding: 0px 0px 0 0; color: white; font-size: 22px; text-align: right;">
                                Behavior within the game title, involving state management, detection, animations, & more. 
                            </p>
                        </div>
                </div>    
        
        
            
		<!-- Footer -->
		<div id="footer">
			<div class="container">

				<div class="row">
					<div class="col-12">

						<!-- Contact -->
						<section class="contact">
							<header>
								<h3 style="color: rgb(0, 255, 0);">Want more?</h3>
							</header>
							<p style="color: white;">Check us out below!</p>
							<ul class="icons">
								<li><a href="https://x.com/ShadowWizGames" target="_blank"
										class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>

								<li><a href="https://www.instagram.com/shadow.wizard.games/" target="_blank"
										class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>

								<li><a href="https://shadowwizardgames.tumblr.com/" target="_blank"
										class="icon brands fa-tumblr"><span class="label">Tumblr</span></a>
								</li>
								<li><a href="mailto:shadow.wizard.m.games@gmail.com" class="icon fa-envelope"><span
											class="label">Email</span></a>
							</ul>
						</section>

						<!-- Copyright -->
						<div class="copyright">
							<ul class="menu">
								<li>&copy; Alien: Nemesis - Shadow Wizard Games. All rights reserved.</li>
							</ul>
						</div>
					</div>

				</div>
			</div>
		</div>

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/jquery.dropotron.min.js"></script>
	<script src="assets/js/jquery.scrolly.min.js"></script>
	<script src="assets/js/jquery.scrollex.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>
	<script src="assets/js/Code.js"></script>
	<script src="assets/js/playbuttondelay.js"></script>
    <script>
        function openTab(evt, tabName) {
            // Declare all variables
            var i, tabcontent, tablinks;
    
            // Get all elements with class="bio-tab-content" and hide them
            tabcontent = document.getElementsByClassName("bio-tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove('active');
            }
    
            // Get all elements with class="bio-tab" and remove the class "active"
            tablinks = document.getElementsByClassName("bio-tab");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
    
            // Show the current tab, and add an "active" class to the button that opened the tab
            document.getElementById(tabName).style.display = "block";
            document.getElementById(tabName).classList.add('active');
            evt.currentTarget.className += " active";
        }
    </script>
    <script>
                        // Define an object to store slide indexes for each slideshow
            let slideIndexes = {};

            // Initialize slide indexes for each slideshow
            function initSlideIndexes() {
                let slideshowContainers = document.querySelectorAll('.slideshow-container');
                slideshowContainers.forEach((container, index) => {
                    slideIndexes['slideshow' + (index + 1)] = 1; // Initialize slide index to 1 for each slideshow
                });
            }

            function showSlides(slideshowIndex, n) {
                let slides = document.querySelectorAll('#' + slideshowIndex + ' .weaponassets');
                if (n > slides.length) { slideIndexes[slideshowIndex] = 1; }
                if (n < 1) { slideIndexes[slideshowIndex] = slides.length; }
                slides.forEach((slide, index) => {
                    slide.style.display = "none";
                });
                slides[slideIndexes[slideshowIndex] - 1].style.display = "block";

                // Update the slide index text
                let slideIndexText = document.querySelector('#' + slideshowIndex + ' .numbertext');
                if (slideIndexText) {
                    slideIndexText.textContent = slideIndexes[slideshowIndex] + ' / ' + slides.length;
                }
            }

            // Change slide for a specific slideshow
            function plusSlides(slideshowIndex, n) {
                showSlides(slideshowIndex, slideIndexes[slideshowIndex] += n);
            }

            // Set up slide indexes for all slideshows
            initSlideIndexes();

            // Show the initial slides for all slideshows
            Object.keys(slideIndexes).forEach(slideshowIndex => {
                showSlides(slideshowIndex, slideIndexes[slideshowIndex]);
            });
    </script>

</body>

</html>

<script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.5.0/model-viewer.min.js"></script>
<!-- Monaco Editor -->
<script src="https://cdn.jsdelivr.net/npm/monaco-editor/min/vs/loader.js"></script>
<script>
    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor/min/vs' }});
    require(['vs/editor/editor.main'], function() {
        function createEditor(id, value, language) {
            const container = document.getElementById(id);
            const editor = monaco.editor.create(container, {
                value: value,
                language: language,
                theme: 'vs-dark',
                readOnly: true // Set editor to read-only
            });

            // Inject CSS rules to round the corners of the editor
            const styleElement = document.createElement('style');
            styleElement.innerHTML = `
                .monaco-editor .overflow-guard,
                .monaco-editor .monaco-scrollable-element {
                    border-radius: 10px;
                    overflow: hidden !important;
                    border: none !important; /* Ensure no border */
                }
            `;
            editor._domElement.appendChild(styleElement); // Append style to the editor's DOM

            // Adjust the layout to fit the container size
            function resizeEditor() {
                const containerRect = container.getBoundingClientRect();
                editor.layout({
                    width: containerRect.width,
                    height: containerRect.height
                });
            }

            // Trigger layout adjustment after editor creation and after a small delay
            resizeEditor();
            setTimeout(resizeEditor, 100); // Delay to ensure correct dimensions

            // Adjust layout on window resize
            window.addEventListener('resize', resizeEditor);
        }

        // Initialize editors
        function initializeEditors() {
        // Editor 1
        createEditor('editor1', `using System;

class AnarchistBehaviour : MonoBehaviour
{
    enum States
    {
        Patrol,
        Inspect,
        Attack,
        Dead
    }

    enum InspctStates
    {
        Going,
        Inspecting,
        ComingBack
    }

    IGameObject playerGO;
    float playerDistance;

    // Anarchist parameters
    float life = 100.0f;
    float biomass = 15.0f;
    float movementSpeed = 13.0f * 3;
    States currentState = States.Patrol;
    States lastState = States.Patrol;
    Vector3 initialPos;

    // Ranges
    const float rangeToInspect = 200.0f;
    const float inspectDetectionRadius = 100.0f;
    const float loseRange = 150.0f;

    // Inspect
    float elapsedTime = 0.0f; //Do not modify
    const float maxInspectTime = 5.0f;
    InspctStates currentSubstate = InspctStates.Going;
    Vector3 playerLastPosition;

    // Attack
    bool shooting = false;
    float timerBetweenBursts = 0.0f; //Do not modify
    const float timeBetweenBursts = 0.5f;
    float timerBetweenBullets = 0.0f; //Do not modify
    const float timeBetweenBullets = 0.05f;
    int bulletCounter = 0; //Do not modify
    const int burstBulletCount = 3;

    // Patrol
    const float patrolRange = 100.0f;
    const float patrolSpeed = 30.0f;
    float roundProgress = 0.0f; //Do not modify
    bool goingToRoundPos = false;

    // Flags
    bool isDead = false;

    // Timers
    float destroyTimer = 0.0f;
    const float destroyCooldown = 3.0f;

    PlayerScript player;
    GameManager gameManager;

    public override void Start()
    {
        playerGO = IGameObject.Find("SK_MainCharacter");
        player = playerGO.GetComponent<PlayerScript>();
        initialPos = attachedGameObject.transform.Position;

        gameManager = IGameObject.Find("GameManager").GetComponent<GameManager>();

        attachedGameObject.animator.Play("Scan");
        attachedGameObject.animator.Blend = true;
        attachedGameObject.animator.TransitionTime = 0.3f;
    }

    public override void Update()
    {
        attachedGameObject.animator.UpdateAnimation();

        if (currentState == States.Dead)
        {
            //destroyTimer += Time.deltaTime;
            //if (destroyTimer >= destroyCooldown)
            //    attachedGameObject.Destroy();

            return;
        }

        if (attachedGameObject.transform.ComponentCheck())
        {
            DebugDraw();

            playerDistance = Vector3.Distance(playerGO.transform.Position, attachedGameObject.transform.Position);

            UpdateFSMStates();
            DoStateBehaviour();
        }
    }

    void UpdateFSMStates()
    {
        if (life <= 0)
        {
            currentState = States.Dead;
            return;
        }

        if (playerDistance < rangeToInspect && lastState != States.Inspect)
        {
            currentState = States.Inspect;
            //Debug.Log("Switching state to Inspect");
        }
    }

    void DoStateBehaviour()
    {
        switch (currentState)
        {
            case States.Patrol:
                Patrol();
                break;
            case States.Inspect:
                Inspect();
                break;
            case States.Attack:
                player.isFighting = true;
                Attack();
                break;
            case States.Dead:
                Dead();
                break;
            default:
                break;
        }
    }

    void Patrol()
    {
        attachedGameObject.animator.Play("Walk");

        if (currentState != lastState)
        {
            lastState = currentState;
            goingToRoundPos = true;
        }

        roundProgress += Time.deltaTime * patrolSpeed;
        if (roundProgress > 360.0f) roundProgress -= 360.0f;

        Vector3 roundPos = initialPos +
                           Vector3.right * (float)Math.Cos(roundProgress * Math.PI / 180.0f) * patrolRange +
                           Vector3.forward * (float)Math.Sin(roundProgress * Math.PI / 180.0f) * patrolRange;

        attachedGameObject.transform.LookAt2D(roundPos);

        if (!goingToRoundPos)
        {
            MoveTo(roundPos);
        }
        else
        {
            goingToRoundPos = !MoveTo(roundPos);
        }
    }

    void Attack()
    {
        attachedGameObject.transform.LookAt2D(playerGO.transform.Position);

        if (playerDistance > loseRange)
        {
            currentState = States.Inspect;
            currentSubstate = InspctStates.ComingBack;
        }

        if (!shooting)
        {
            timerBetweenBursts += Time.deltaTime;
            if (timerBetweenBursts > timeBetweenBursts)
            {
                timerBetweenBursts = 0.0f;
                shooting = true;
            }
        }
        else
        {
            timerBetweenBullets += Time.deltaTime;
            if (timerBetweenBullets > timeBetweenBullets)
            {
                attachedGameObject.animator.Play("Shoot");
                Vector3 height = new Vector3(0.0f, 30.0f, 0.0f);
                InternalCalls.InstantiateBullet(attachedGameObject.transform.Position + attachedGameObject.transform.Forward * 13.5f + height, attachedGameObject.transform.Rotation);
                timerBetweenBullets = 0.0f;
                bulletCounter++;
                attachedGameObject.source.Play(IAudioSource.AudioEvent.E_A_SHOOT);
            }

            if (bulletCounter >= burstBulletCount)
            {
                bulletCounter = 0;
                shooting = false;
            }
        }


    }

    void Inspect()
    {
        if (currentState != lastState)
        {
            //Debug.Log("Anarchist starting state");
            lastState = currentState;
            playerLastPosition = playerGO.transform.Position;
        }

        switch (currentSubstate)
        {
            case InspctStates.Going:
                attachedGameObject.animator.Play("Walk");
                if (MoveTo(playerLastPosition))
                {
                    currentSubstate = InspctStates.Inspecting;
                }
                attachedGameObject.transform.LookAt2D(playerLastPosition);
                break;
            case InspctStates.Inspecting:
                attachedGameObject.animator.Play("Scan");
                elapsedTime += Time.deltaTime;
                if (elapsedTime > maxInspectTime)
                {
                    elapsedTime = 0.0f;
                    currentSubstate = InspctStates.ComingBack;
                }
                break;
            case InspctStates.ComingBack:
                attachedGameObject.animator.Play("Walk");
                if (MoveTo(initialPos))
                {
                    currentSubstate = InspctStates.Going;
                    currentState = States.Patrol;
                }
                attachedGameObject.transform.LookAt2D(initialPos);
                break;
            default:
                break;
        }

        Vector3 directorVec = (attachedGameObject.transform.Position - playerGO.transform.Position).Normalize();
        float dot = Vector3.Dot(attachedGameObject.transform.Forward, directorVec);

        if (playerDistance < inspectDetectionRadius && dot > 0.7f)
        {
            currentState = States.Attack;
        }
    }

    void Dead()
    {
        if (!isDead)
        {
            attachedGameObject.animator.Play("Death");
            isDead = true;
            player.shieldKillCounter++;
            // add player biomass
        }
    }

    bool MoveTo(Vector3 targetPosition)
    {
        //Return true if arrived at destination
        if (Vector3.Distance(attachedGameObject.transform.Position, targetPosition) < 0.5f) return true;

        Vector3 dirVector = (targetPosition - attachedGameObject.transform.Position).Normalize();
        attachedGameObject.transform.Translate(dirVector * movementSpeed * Time.deltaTime);
        return false;
    }

    public void ReduceLife() //temporary function for the hardcoding of collisions
    {
        life -= player.totalDamage;
        if (life < 0) life = 0;
    }

    public void ReduceLifeExplosion()
    {
        life -= player.GrenadeLauncher.damage;
        if (life < 0) life = 0;
    }

    private void DebugDraw()
    {
        if (gameManager.colliderRender)
        {
            Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 3, loseRange, Vector3.right);
            Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 3, rangeToInspect, Vector3.right + Vector3.up);

            switch (currentSubstate)
            {
                case InspctStates.Going:
                    Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 3, inspectDetectionRadius, Vector3.right + Vector3.up * 0.3f);
                    break;
                case InspctStates.Inspecting:
                    Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 3, inspectDetectionRadius, Vector3.right + Vector3.up * 0.5f);
                    break;
                case InspctStates.ComingBack:
                    Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 3, inspectDetectionRadius, Vector3.right + Vector3.up * 0.8f);
                    break;
                default:
                    break;
            }
        }
    }
}
`, 'cpp');

        // Editor 2
        createEditor('editor2', `Ôªøusing System;

public class ChestbursterBehaviour : MonoBehaviour
{
    enum States
    {
        Idle,
        Chase,
        Attack,
        Dead
    }

    private enum ChestbursterAttack
    {
        None,
        TailPunch,
        TailTrip
    }

    IGameObject playerGO;
    Vector3 directorVector;
    float playerDistance;

    // Chestburster parameters
    float life = 80.0f;
    float biomass = 10.0f;
    float movementSpeed = 30.0f * 2;
    States currentState = States.Idle;
    ChestbursterAttack currentAttack = ChestbursterAttack.None;

    // Ranges
    const float detectedRange = 35.0f * 1.5f;
    const float isCloseRange = 60.0f;
    const float maxChasingRange = 150.0f;
    const float maxRangeStopChasing = 25.0f;

    // Flags
    bool isClose = false;
    bool detected = false;
    bool isDead = false;

    // Timers
    float attackTimer = 0.0f;
    const float attackCooldown = 4.0f;
    float destroyTimer = 0.0f;
    const float destroyCooldown = 3.0f;

    PlayerScript player;
    GameManager gameManager;

    // Particles
    IParticleSystem tailPunchPSGO;
    IParticleSystem tailTripPSGO;
    IParticleSystem deathPSGO;

    public override void Start()
    {
        playerGO = IGameObject.Find("SK_MainCharacter");
        player = playerGO.GetComponent<PlayerScript>();

        gameManager = IGameObject.Find("GameManager").GetComponent<GameManager>();

        attachedGameObject.animator.Play("Move");
        attachedGameObject.animator.Blend = true;
        attachedGameObject.animator.TransitionTime = 0.3f;

        tailPunchPSGO = attachedGameObject.FindInChildren("TailPunchPS")?.GetComponent<IParticleSystem>();
        tailTripPSGO = attachedGameObject.FindInChildren("TailTripPS")?.GetComponent<IParticleSystem>();
        deathPSGO = attachedGameObject.FindInChildren("DeathPS")?.GetComponent<IParticleSystem>();
    }

    public override void Update()
    {
        attachedGameObject.animator.UpdateAnimation();

        if (currentState == States.Dead)
        {
            //destroyTimer += Time.deltaTime;
            //if (destroyTimer >= destroyCooldown)
            //    attachedGameObject.Destroy();

            return;
        }

        if (attachedGameObject.transform.ComponentCheck())
        {
            DebugDraw();

            directorVector = (playerGO.transform.Position - attachedGameObject.transform.Position).Normalize();
            playerDistance = Vector3.Distance(playerGO.transform.Position, attachedGameObject.transform.Position);

            UpdateFSM();
            DoStateBehaviour();
        }
    }

    void UpdateFSM()
    {
        if (life <= 0)
        {
            currentState = States.Dead;
            //Debug.Log("Chestburster switched to Dead");
            return;
        }

        if (!detected && playerDistance < detectedRange)
        {
            detected = true;
            currentState = States.Chase;
            //Debug.Log("Chestburster switched to Chase");
        }

        if (detected)
        {
            CheckIsClose();

            if (currentAttack == ChestbursterAttack.None)
            {
                attackTimer += Time.deltaTime;
                attachedGameObject.animator.Play("Run");
            }

            CheckIsMaxRangeStopChasing();

            if (currentAttack == ChestbursterAttack.None && attackTimer >= attackCooldown)
            {
                currentState = States.Attack;
                //Debug.Log("Chestburster switched to Attack");
            }

            if (playerDistance > maxChasingRange && currentState != States.Attack)
            {
                detected = false;
                currentState = States.Idle;
                //Debug.Log("Chestburster switched to Idle");
            }
        }
    }

    private void CheckIsClose()
    {
        if (playerDistance < isCloseRange && !isClose)
        {
            isClose = true;
            //Debug.Log("Player is now CLOSE");
        }

        if (playerDistance >= isCloseRange && isClose)
        {
            isClose = false;
            //Debug.Log("Player is now FAR");
        }
    }

    private void CheckIsMaxRangeStopChasing()
    {
        if (playerDistance <= maxRangeStopChasing && currentAttack == ChestbursterAttack.None &&
               currentState != States.Idle)
        {
            currentState = States.Idle;
            //Debug.Log("Player is INSIDE maxRangeStopChasing");
        }

        if (playerDistance > maxRangeStopChasing && currentAttack == ChestbursterAttack.None &&
            currentState != States.Chase)
        {
            currentState = States.Chase;
            //Debug.Log("Player is OUTSIDE maxRangeStopChasing");
        }
    }

    void DoStateBehaviour()
    {
        switch (currentState)
        {
            case States.Idle:
                if (currentAttack == ChestbursterAttack.None && detected)
                    attachedGameObject.transform.LookAt2D(playerGO.transform.Position);

                break;
            case States.Chase:
                player.isFighting = true;
                attachedGameObject.transform.Translate(attachedGameObject.transform.Forward * movementSpeed * Time.deltaTime);
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                break;
            case States.Attack:
                player.isFighting = true;
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                ChooseAttack();
                switch (currentAttack)
                {
                    case ChestbursterAttack.TailPunch:
                        TailPunch();
                        break;
                    case ChestbursterAttack.TailTrip:
                        TailTrip();
                        break;
                    default:
                        break;
                }
                break;
            case States.Dead:
                Dead();
                break;
            default:
                break;
        }
    }

    private void ChooseAttack()
    {
        if (currentAttack == ChestbursterAttack.None)
        {
            if (isClose)
            {
                currentAttack = ChestbursterAttack.TailPunch;
                attachedGameObject.animator.Play("TailPunch");
                tailPunchPSGO.Play();
            }
            else
            {
                currentAttack = ChestbursterAttack.TailTrip;
                attachedGameObject.animator.Play("TailTrip");
                tailTripPSGO.Play();
            }
            //Debug.Log("Chestburster current attack: " + currentAttack);
        }
    }

    private void TailPunch()
    {
        //Debug.Log("Attempt to do TailPunch");

        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            ResetState();
        }

    }

    private void TailTrip()
    {
        //Debug.Log("Attempt to do TailTrip");

        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            ResetState();
        }

    }

    private void Dead()
    {
        if (!isDead)
        {
            attachedGameObject.animator.Play("Die");

            isDead = true;
            player.shieldKillCounter++;
            // add player biomass
            deathPSGO.Play();
        }
    }

    private void ResetState()
    {
        //Debug.Log("Reset State");
        attackTimer = 0.0f;
        currentAttack = ChestbursterAttack.None;
        currentState = States.Chase;
        attachedGameObject.animator.Play("Run");
    }

    public void ReduceLife() //temporary function for the hardcoding of collisions
    {
        life -= player.totalDamage;
        if (life < 0) life = 0;
        Debug.Log("Chestburster health: " + life.ToString());
    }

    public void ReduceLifeExplosion()
    {
        life -= player.GrenadeLauncher.damage;
        if (life < 0) life = 0;
    }

    private void DebugDraw()
    {
        //Draw debug ranges
        if (gameManager.colliderRender)
        {
            if (!detected)
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, detectedRange, new Vector3(1.0f, 0.8f, 0.0f)); //Yellow
            }
            else
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, maxChasingRange, new Vector3(0.9f, 0.0f, 0.9f)); //Purple
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, isCloseRange, new Vector3(0.0f, 0.8f, 1.0f)); //Blue
            }
        }
    }
}`, 'cpp');

        // Editor 3
        createEditor('editor3', `Ôªøusing System;

public class FaceHuggerBehaviour : MonoBehaviour
{
    enum States
    {
        Idle,
        Chase,
        JumpAttack,
        Hug,
        Land,
        Dead
    }

    IGameObject playerGO;
    Vector3 directorVector;
    float playerDistance;

    // Facehugger parameters
    float life = 40.0f;
    float biomass = 10.0f;
    float movementSpeed = 35.0f * 2;
    States currentState = States.Idle;

    // Ranges
    const float detectedRange = 180.0f;
    const float maxAttackRange = 90.0f;
    const float maxChasingRange = 180.0f;
    const float maxRangeStopChasing = 60.0f;

    // Flags
    bool detected = false;
    bool hitPlayer = false;
    bool isDead = false;
    bool isJumping = false;
    bool isHugging = false;
    bool isLanding = false;
    bool fallDead = false;
    bool shotDead = false;

    // Timers
    float jumpAttackTimer = 0.0f;
    const float jumpAttackCooldown = 3.0f;

    PlayerScript player;
    GameManager gameManager;

    IParticleSystem jumpPS;
    IParticleSystem deathPS;

    public override void Start()
    {
        playerGO = IGameObject.Find("SK_MainCharacter");
        player = playerGO.GetComponent<PlayerScript>();

        gameManager = IGameObject.Find("GameManager").GetComponent<GameManager>();

        attachedGameObject.animator.Play("Idle");
        attachedGameObject.animator.Blend = true;
        attachedGameObject.animator.TransitionTime = 0.3f;

        jumpPS = attachedGameObject.FindInChildren("JumpPS")?.GetComponent<IParticleSystem>();
        deathPS = attachedGameObject.FindInChildren("DeathPS")?.GetComponent<IParticleSystem>();
    }

    public override void Update()
    {
        attachedGameObject.animator.UpdateAnimation();

        if (currentState == States.Dead) return;

        if (attachedGameObject.transform.ComponentCheck())
        {
            DebugDraw();

            // Set the director vector and distance to the player
            directorVector = (playerGO.transform.Position - attachedGameObject.transform.Position).Normalize();
            playerDistance = Vector3.Distance(playerGO.transform.Position, attachedGameObject.transform.Position);

            UpdateFSM();
            DoStateBehaviour();
        }
    }

    void UpdateFSM()
    {
        if (life <= 0 || fallDead)
        {
            if (attachedGameObject.animator.CurrentAnimHasFinished || shotDead)
                currentState = States.Dead;
            //Debug.Log("Facehugger switched to Dead");
            return;
        }

        if (!detected && playerDistance < detectedRange)
        {
            detected = true;
            currentState = States.Chase;
            //Debug.Log("Facehugger switched to Chase");
        }

        if (detected)
        {
            if (currentState != States.JumpAttack &&
                currentState != States.Hug && currentState != States.Land)
            {
                jumpAttackTimer += Time.deltaTime;
                if (currentState != States.Idle)
                    attachedGameObject.animator.Play("Walk");
            }

            CheckIsMaxRangeStopChasing();

            if (jumpAttackTimer >= jumpAttackCooldown && currentState != States.JumpAttack)
            {
                currentState = States.JumpAttack;
                //Debug.Log("Facehugger switched to JumpAttack");
            }

            if (playerDistance > maxChasingRange && currentState != States.JumpAttack &&
                currentState != States.Hug && currentState != States.Land)
            {
                detected = false;
                currentState = States.Idle;
                //Debug.Log("Facehugger switched to Idle");
            }
        }
    }

    private void CheckIsMaxRangeStopChasing()
    {
        if (playerDistance <= maxRangeStopChasing && currentState != States.Idle)
        {
            currentState = States.Idle;
            //Debug.Log("Player is INSIDE maxRangeStopChasing");
        }
        else if (playerDistance > maxRangeStopChasing && currentState != States.Chase &&
                 currentState != States.Hug)
        {

            currentState = States.Chase;
            //Debug.Log("Player is OUTSIDE maxRangeStopChasing");
        }
    }

    void DoStateBehaviour()
    {
        switch (currentState)
        {
            case States.Idle:
                attachedGameObject.animator.Play("Idle");
                return;
            case States.Chase:
                player.isFighting = true;
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                attachedGameObject.transform.Translate(attachedGameObject.transform.Forward * movementSpeed * Time.deltaTime);
                break;
            case States.JumpAttack:
                player.isFighting = true;
                attachedGameObject.transform.Translate(attachedGameObject.transform.Forward * movementSpeed * Time.deltaTime);
                JumpAttack();
                break;
            case States.Hug:
                Hug();
                break;
            case States.Land:
                Land();
                break;
            case States.Dead:
                Dead();
                break;
            default:
                break;
        }
    }

    private void JumpAttack()
    {
        if (!isJumping)
        {
            isJumping = true;
            attachedGameObject.animator.Play("Jump");
            if (jumpPS != null) jumpPS.Replay();
        }

        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            CheckIsHugging();
        }
    }

    private void CheckIsHugging()
    {
        jumpAttackTimer = 0.0f;
        isJumping = false;
        if (hitPlayer)
        {
            currentState = States.Hug;
        }
        else
        {
            currentState = States.Land;
        }
    }

    private void Hug()
    {
        if (!isHugging)
        {
            attachedGameObject.animator.Play("Hug");
            isHugging = true;
        }

        fallDead = true;
        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            isHugging = false;
            fallDead = true;
        }
    }

    private void Land()
    {
        if (!isLanding)
        {
            attachedGameObject.animator.Play("Land");
            isLanding = true;
        }

        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            currentState = States.Chase;
            isLanding = false;
        }
    }

    private void Dead()
    {
        if (!isDead)
        {
            if (fallDead) attachedGameObject.animator.Play("FallAndDie");

            if (shotDead) attachedGameObject.animator.Play("ShotAndDie");

            isDead = true;
            player.shieldKillCounter++;
            // add player biomass
            if (deathPS != null) deathPS.Replay(); // this will crash if no particles are found
        }
    }

    public void CheckJump() //temporary function for the hardcoding of collisions
    {
        if (!hitPlayer)
        {
            if (isJumping)
            {
                playerGO.GetComponent<PlayerScript>().ReduceLife(10);
                hitPlayer = true;
                fallDead = true;
            }
        }
    }

    public void ReduceLife() //temporary function for the hardcoding of collisions
    {
        life -= player.totalDamage;
        if (life < 0)
        {
            life = 0;
            shotDead = true;
        }
    }

    private void DebugDraw()
    {
        //Draw debug ranges
        if (gameManager.colliderRender)
        {
            if (!detected)
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, detectedRange, new Vector3(1.0f, 0.8f, 0.0f)); //Yellow
            }
            else
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, maxChasingRange, new Vector3(0.9f, 0.0f, 0.9f)); //Purple
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, maxAttackRange, new Vector3(0.0f, 0.8f, 1.0f)); //Blue
            }
        }
    }
}`, 'cpp');

// Editor 4
createEditor('editor4', `Ôªøusing System;

public class AdultXenomorphBehaviour : MonoBehaviour
{
    enum States
    {
        Idle,
        Attack,
        Chase,
        Patrol,
        Dead
    }

    private enum AdultXenomorphAttacks
    {
        None,
        AcidSpit,
        TailAttack
    }

    IGameObject playerGO;
    Vector3 directorVector;
    float playerDistance;

    // Adult Xenomorph parameters
    float life = 200.0f;
    float biomass = 20.0f;
    float movementSpeed = 18.0f * 3;
    
    States currentState = States.Idle;
    States lastState = States.Idle;
    AdultXenomorphAttacks currentAttack = AdultXenomorphAttacks.None;
    Vector3 initialPos;

    // Patrol
    readonly float patrolRange = 100;
    readonly float patrolSpeed = 20.0f;
    float roundProgress = 0.0f; //Do not modify
    bool goingToRoundPos = false;

    // Ranges
    const float detectedRange = 180.0f;
    const float isCloseRange = 20.0f * 3;
    const float maxChasingRange = 180.0f;
    const float maxRangeStopChasing = 25.0f;

    // Flags
    bool detected = false;
    bool isClose = false;
    bool isDead = false;
    bool hasShot = false;

    // Timers
    float attackTimer = 0.0f;
    const float attackCooldown = 2.0f;
    float destroyTimer = 0.0f;
    const float destroyCooldown = 3.0f;
    float delayTimer = 0.0f;
    const float delayCooldown = 1.2f;

    PlayerScript player;
    GameManager gameManager;

    // Particles
    IParticleSystem acidSpitPSGO;
    IParticleSystem tailAttackPSGO;
    IParticleSystem deathPSGO;

    public override void Start()
    {
        playerGO = IGameObject.Find("SK_MainCharacter");
        player = playerGO.GetComponent<PlayerScript>();
        initialPos = attachedGameObject.transform.Position;

        gameManager = IGameObject.Find("GameManager").GetComponent<GameManager>();

        attachedGameObject.animator.Play("Walk");
        attachedGameObject.animator.Blend = true;
        attachedGameObject.animator.TransitionTime = 0.3f;

        acidSpitPSGO = attachedGameObject.FindInChildren("AcidSpitPS")?.GetComponent<IParticleSystem>();
        tailAttackPSGO = attachedGameObject.FindInChildren("TailAttackPS")?.GetComponent<IParticleSystem>();
        deathPSGO = attachedGameObject.FindInChildren("DeathPS")?.GetComponent<IParticleSystem>();
    }

    public override void Update()
    {
        attachedGameObject.animator.UpdateAnimation();

        if (currentState == States.Dead)
        {
            //destroyTimer += Time.deltaTime;
            //if (destroyTimer >= destroyCooldown)
            //    attachedGameObject.Destroy();

            return;
        }

        if (attachedGameObject.transform.ComponentCheck())
        {
            DebugDraw();

            //Set the director vector and distance to the player
            directorVector = (playerGO.transform.Position - attachedGameObject.transform.Position).Normalize();
            playerDistance = Vector3.Distance(playerGO.transform.Position, attachedGameObject.transform.Position);

            UpdateFSM();
            DoStateBehaviour();
        }
    }

    void UpdateFSM()
    {
        if (life <= 0)
        {
            currentState = States.Dead;
            return;
        }

        if (!detected && playerDistance < detectedRange)
        {
            detected = true;
            currentState = States.Chase;
            //Debug.Log("Adult Xenomorph switched to Chase");
        }

        if (detected)
        {
            CheckIsClose();

            if (currentAttack == AdultXenomorphAttacks.None)
            {
                attackTimer += Time.deltaTime;
                attachedGameObject.animator.Play("Walk");
            }

            CheckIsMaxRangeStopChasing();

            if (currentAttack == AdultXenomorphAttacks.None && attackTimer >= attackCooldown)
            {
                currentState = States.Attack;
                //Debug.Log("Adult Xenomorph switched to Attack");
            }

            if (playerDistance > maxChasingRange && currentState != States.Attack)
            {
                detected = false;
                currentState = States.Patrol;
                //Debug.Log("Adult Xenomorph switched to Patrol");
            }
        }
    }

    private void CheckIsClose()
    {
        if (playerDistance < isCloseRange && !isClose)
        {
            isClose = true;
            //Debug.Log("Player is now CLOSE");
        }
        else if (playerDistance >= isCloseRange && isClose)
        {
            isClose = false;
            //Debug.Log("Player is now FAR");
        }
    }

    private void CheckIsMaxRangeStopChasing()
    {
        if (playerDistance <= maxRangeStopChasing && currentAttack == AdultXenomorphAttacks.None &&
            currentState != States.Idle)
        {
            currentState = States.Idle;
            //Debug.Log("Player is INSIDE maxRangeStopChasing");
        }
        else if (playerDistance > maxRangeStopChasing && currentAttack == AdultXenomorphAttacks.None &&
                 currentState != States.Chase)
        {
            currentState = States.Chase;
            //Debug.Log("Player is OUTSIDE maxRangeStopChasing");
        }
    }

    private void DoStateBehaviour()
    {
        switch (currentState)
        {
            case States.Idle:
                return;
            case States.Attack:
                player.isFighting = true;
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                ChooseAttack();
                switch (currentAttack)
                {
                    case AdultXenomorphAttacks.AcidSpit:
                        AcidSpit();
                        break;
                    case AdultXenomorphAttacks.TailAttack:
                        TailAttack();
                        break;
                    default:
                        break;
                }
                break;
            case States.Chase:
                player.isFighting = true;
                attachedGameObject.transform.Translate(attachedGameObject.transform.Forward * movementSpeed * Time.deltaTime);
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                break;
            case States.Patrol:
                Patrol();
                break;
            case States.Dead:
                Dead();
                break;
            default:
                break;
        }
    }

    private void ChooseAttack()
    {
        if (currentAttack == AdultXenomorphAttacks.None)
        {
            if (isClose)
            {
                currentAttack = AdultXenomorphAttacks.TailAttack;
                attachedGameObject.animator.Play("TailAttack");
                tailAttackPSGO.Play();
            }
            else
            {
                currentAttack = AdultXenomorphAttacks.AcidSpit;
                attachedGameObject.animator.Play("Spit");
                acidSpitPSGO.Play();
            }
            //Debug.Log("AdultXenomorph current attack: " + currentAttack);
        }
    }

    private void AcidSpit()
    {
        delayTimer += Time.deltaTime;

        if (!hasShot && delayTimer >= delayCooldown)
        {
            hasShot = true;
            Vector3 height = new Vector3(0.0f, 38.0f, 0.0f);
            InternalCalls.InstantiateBullet(attachedGameObject.transform.Position + attachedGameObject.transform.Forward * 13.5f + height, attachedGameObject.transform.Rotation);
            // SFX Goes here
        }

        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            hasShot = false;
            delayTimer = 0.0f;
            ResetState();
        }
    }

    private void TailAttack()
    {
        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            ResetState();
        }
    }

    private void Patrol()
    {
        attachedGameObject.animator.Play("Walk");

        if (currentState != lastState)
        {
            lastState = currentState;
            goingToRoundPos = true;
        }

        roundProgress += Time.deltaTime * patrolSpeed;
        if (roundProgress > 360.0f) roundProgress -= 360.0f;

        Vector3 roundPos = initialPos +
                           Vector3.right * (float)Math.Cos(roundProgress * Math.PI / 180.0f) * patrolRange +
                           Vector3.forward * (float)Math.Sin(roundProgress * Math.PI / 180.0f) * patrolRange;

        attachedGameObject.transform.LookAt2D(roundPos);
        if (!goingToRoundPos)
        {
            MoveTo(roundPos);
        }
        else
        {
            goingToRoundPos = !MoveTo(roundPos);
        }
    }

    private void Dead()
    {
        if (!isDead)
        {
            attachedGameObject.animator.Play("Death");

            isDead = true;
            player.shieldKillCounter++;
            // add player biomass
            deathPSGO.Play();
        }
    }

    private void ResetState()
    {
        attackTimer = 0.0f;
        currentAttack = AdultXenomorphAttacks.None;
        currentState = States.Chase;
    }

    public void ReduceLife() //temporary function for the hardcoding of collisions
    {
        life -= player.totalDamage;
        if (life < 0) life = 0;
    }

    public void ReduceLifeExplosion()
    {
        life -= player.GrenadeLauncher.damage;
        if (life < 0) life = 0;
    }

    private bool MoveTo(Vector3 targetPosition)
    {
        //Return true if arrived at destination
        if (Vector3.Distance(attachedGameObject.transform.Position, targetPosition) < 0.5f) return true;

        Vector3 dirVector = (targetPosition - attachedGameObject.transform.Position).Normalize();
        attachedGameObject.transform.Translate(dirVector * movementSpeed * Time.deltaTime);
        //attachedGameObject.source.PlayAudio(AudioManager.EventIDs.E_REBEL_STEP);
        return false;
    }

    private void DebugDraw()
    {
        //Draw debug ranges
        if (gameManager.colliderRender)
        {
            if (!detected)
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, detectedRange, new Vector3(1.0f, 0.8f, 0.0f)); //Yellow
            }
            else
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, isCloseRange, new Vector3(1.0f, 0.0f, 0.0f)); //Red
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, maxChasingRange, new Vector3(1.0f, 0.0f, 1.0f)); //Purple
            }
        }
    }
}`, 'cpp');

// Editor 5
createEditor('editor5', `using System;

public class RedXenomorphBehaviour : MonoBehaviour
{
    enum States
    {
        Idle,
        Attack,
        Chase,
        Patrol,
        Dead
    }

    private enum RedXenomorphAttacks
    {
        None,
        SpikeThrow,
        TailStab
    }

    IGameObject playerGO;
    Vector3 directorVector;
    float playerDistance;

    // Red Xenomorph parameters
    float life = 250.0f;
    float biomass = 25.0f;
    float movementSpeed = 18.0f * 3;
    States currentState = States.Idle;
    States lastState = States.Idle;
    RedXenomorphAttacks currentAttack = RedXenomorphAttacks.None;
    Vector3 initialPos;

    // Patrol
    const float patrolRange = 100.0f;
    float patrolSpeed = 20.0f;
    float roundProgress = 0.0f; //Do not modify
    bool goingToRoundPos = false;

    // Ranges
    const float detectedRange = 180.0f;
    const float isCloseRange = 20.0f * 3;
    const float maxChasingRange = 180.0f;
    const float maxRangeStopChasing = 25.0f;

    // Flags
    bool detected = false;
    bool isClose = false;
    bool isDead = false;
    bool hasShot = false;

    // Timers
    float attackTimer = 0.0f;
    const float attackCooldown = 2.0f;
    float destroyTimer = 0.0f;
    const float destroyCooldown = 3.0f;
    float delayTimer = 0.0f;
    const float delayCooldown = 1.2f;

    PlayerScript player;
    GameManager gameManager;

    // Particles
    IParticleSystem acidSpitPSGO;
    IParticleSystem tailAttackPSGO;
    IParticleSystem deathPSGO;

    public override void Start()
    {
        playerGO = IGameObject.Find("SK_MainCharacter");
        player = playerGO.GetComponent<PlayerScript>();
        initialPos = attachedGameObject.transform.Position;

        gameManager = IGameObject.Find("GameManager").GetComponent<GameManager>();

        attachedGameObject.animator.Play("Walk");
        attachedGameObject.animator.Blend = true;
        attachedGameObject.animator.TransitionTime = 0.3f;

        acidSpitPSGO = attachedGameObject.FindInChildren("AcidSpitPS")?.GetComponent<IParticleSystem>();
        tailAttackPSGO = attachedGameObject.FindInChildren("TailAttackPS")?.GetComponent<IParticleSystem>();
        deathPSGO = attachedGameObject.FindInChildren("DeathPS")?.GetComponent<IParticleSystem>();
    }

    public override void Update()
    {
        attachedGameObject.animator.UpdateAnimation();

        if (currentState == States.Dead)
        {
            //destroyTimer += Time.deltaTime;
            //if (destroyTimer >= destroyCooldown)
            //    attachedGameObject.Destroy();

            return;
        }

        if (attachedGameObject.transform.ComponentCheck())
        {
            DebugDraw();

            //Set the director vector and distance to the player
            directorVector = (playerGO.transform.Position - attachedGameObject.transform.Position).Normalize();
            playerDistance = Vector3.Distance(playerGO.transform.Position, attachedGameObject.transform.Position);

            UpdateFSM();
            DoStateBehaviour();
        }
    }

    void UpdateFSM()
    {
        if (life <= 0)
        {
            currentState = States.Dead;
            return;
        }

        if (!detected && playerDistance < detectedRange)
        {
            detected = true;
            currentState = States.Chase;
            //Debug.Log("Red Xenomorph switched to Chase");
        }

        if (detected)
        {
            CheckIsClose();

            if (currentAttack == RedXenomorphAttacks.None)
            {
                attackTimer += Time.deltaTime;
                attachedGameObject.animator.Play("Walk");
            }

            CheckIsMaxRangeStopChasing();

            if (currentAttack == RedXenomorphAttacks.None && attackTimer >= attackCooldown)
            {
                currentState = States.Attack;
                //Debug.Log("Red Xenomorph switched to Attack");
            }

            if (playerDistance > maxChasingRange && currentState != States.Attack)
            {
                detected = false;
                currentState = States.Patrol;
                //Debug.Log("Red Xenomorph switched to Patrol");
            }
        }
    }

    private void CheckIsClose()
    {
        if (playerDistance < isCloseRange && !isClose)
        {
            isClose = true;
            //Debug.Log("Player is now CLOSE");
        }
        else if (playerDistance >= isCloseRange && isClose)
        {
            isClose = false;
            //Debug.Log("Player is now FAR");
        }
    }

    private void CheckIsMaxRangeStopChasing()
    {
        if (playerDistance <= maxRangeStopChasing && currentAttack == RedXenomorphAttacks.None &&
            currentState != States.Idle)
        {
            currentState = States.Idle;
            //Debug.Log("Player is INSIDE maxRangeStopChasing");
        }
        else if (playerDistance > maxRangeStopChasing && currentAttack == RedXenomorphAttacks.None &&
                 currentState != States.Chase)
        {
            currentState = States.Chase;
            //Debug.Log("Player is OUTSIDE maxRangeStopChasing");
        }
    }

    void DoStateBehaviour()
    {
        switch (currentState)
        {
            case States.Idle:
                return;
            case States.Attack:
                player.isFighting = true;
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                ChooseAttack();
                switch (currentAttack)
                {
                    case RedXenomorphAttacks.SpikeThrow:
                        SpikeThrow();
                        break;
                    case RedXenomorphAttacks.TailStab:
                        TailStab();
                        break;
                    default:
                        break;
                }
                break;
            case States.Chase:
                player.isFighting = true;
                attachedGameObject.transform.Translate(attachedGameObject.transform.Forward * movementSpeed * Time.deltaTime);
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                break;
            case States.Patrol:
                Patrol();
                break;
            case States.Dead:
                Dead();
                break;
            default:
                break;
        }
    }

    private void ChooseAttack()
    {
        if (currentAttack == RedXenomorphAttacks.None)
        {
            if (isClose)
            {
                currentAttack = RedXenomorphAttacks.TailStab;
                attachedGameObject.animator.Play("TailStab");
                tailAttackPSGO.Play();
            }
            else
            {
                currentAttack = RedXenomorphAttacks.SpikeThrow;
                attachedGameObject.animator.Play("SpikeThrow");
                acidSpitPSGO.Play();
            }
            //Debug.Log("RedXenomorph current attack: " + currentAttack);
        }
    }

    private void SpikeThrow()
    {
        delayTimer += Time.deltaTime;

        if (!hasShot && delayTimer >= delayCooldown)
        {
            hasShot = true;
            Vector3 height = new Vector3(0.0f, 38.0f, 0.0f);
            InternalCalls.InstantiateBullet(attachedGameObject.transform.Position + attachedGameObject.transform.Forward * 13.5f + height, attachedGameObject.transform.Rotation);
            // SFX Goes here
        }

        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            hasShot = false;
            delayTimer = 0.0f;
            ResetState();
        }
    }

    private void TailStab()
    {
        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            ResetState();
        }
    }

    private void Patrol()
    {
        attachedGameObject.animator.Play("Walk");

        if (currentState != lastState)
        {
            lastState = currentState;
            goingToRoundPos = true;
        }

        roundProgress += Time.deltaTime * patrolSpeed;
        if (roundProgress > 360.0f) roundProgress -= 360.0f;

        Vector3 roundPos = initialPos +
                           Vector3.right * (float)Math.Cos(roundProgress * Math.PI / 180.0f) * patrolRange +
                           Vector3.forward * (float)Math.Sin(roundProgress * Math.PI / 180.0f) * patrolRange;

        attachedGameObject.transform.LookAt2D(roundPos);
        if (!goingToRoundPos)
        {
            MoveTo(roundPos);
        }
        else
        {
            goingToRoundPos = !MoveTo(roundPos);
        }
    }

    private void Dead()
    {
        if (!isDead)
        {
            attachedGameObject.animator.Play("Death");
            isDead = true;
            player.shieldKillCounter++;
            // add player biomass
            deathPSGO.Play();
        }
    }

    private void ResetState()
    {
        attackTimer = 0.0f;
        currentAttack = RedXenomorphAttacks.None;
        currentState = States.Chase;
    }

    public void ReduceLife() //temporary function for the hardcoding of collisions
    {
        life -= player.totalDamage;
        if (life < 0) life = 0;
    }
    public void ReduceLifeExplosion()
    {
        life -= player.GrenadeLauncher.damage;
        if (life < 0) life = 0;
    }

    private bool MoveTo(Vector3 targetPosition)
    {
        //Return true if arrived at destination
        if (Vector3.Distance(attachedGameObject.transform.Position, targetPosition) < 0.5f) return true;

        Vector3 dirVector = (targetPosition - attachedGameObject.transform.Position).Normalize();
        attachedGameObject.transform.Translate(dirVector * movementSpeed * Time.deltaTime);
        //attachedGameObject.source.PlayAudio(AudioManager.EventIDs.E_REBEL_STEP);
        return false;
    }

    private void DebugDraw()
    {
        //Draw debug ranges
        if (gameManager.colliderRender)
        {
            if (!detected)
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, detectedRange, new Vector3(1.0f, 0.8f, 0.0f)); //Yellow
            }
            else
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, isCloseRange, new Vector3(1.0f, 0.0f, 0.0f)); //Red
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, maxChasingRange, new Vector3(1.0f, 0.0f, 1.0f)); //Purple
            }
        }
    }
}`, 'cpp');

// Editor 6
createEditor('editor6', `Ôªøusing System;

public class WhiteXenomorphBehaviour : MonoBehaviour
{
    enum States
    {
        Idle,
        Attack,
        Chase,
        Patrol,
        Dead
    }

    private enum WhiteXenomorphAttacks
    {
        None,
        ClawAttack,
        TailTrip
    }

    IGameObject playerGO;
    float playerDistance;

    // White Xenomorph parameters
    float life = 350.0f;
    float biomass = 30.0f;
    float movementSpeed = 20.0f * 3;
    States currentState = States.Idle;
    States lastState = States.Idle;
    WhiteXenomorphAttacks currentAttack = WhiteXenomorphAttacks.None;
    Vector3 initialPos;

    // Patrol
    readonly float patrolRange = 100;
    readonly float patrolSpeed = 20.0f;
    float roundProgress = 0.0f; //Do not modify
    bool goingToRoundPos = false;

    // Ranges
    const float detectedRange = 180.0f;
    const float isCloseRange = 20.0f * 3;
    const float maxChasingRange = 180.0f;
    const float maxRangeStopChasing = 25.0f;

    // Flags
    bool detected = false;
    bool isClose = false;
    bool isDead = false;

    // Timers
    float attackTimer = 0.0f;
    const float attackCooldown = 2.0f;
    float destroyTimer = 0.0f;
    const float destroyCooldown = 3.0f;

    PlayerScript player;
    GameManager gameManager;

    // Particles
    IParticleSystem acidSpitPSGO;
    IParticleSystem tailAttackPSGO;
    IParticleSystem deathPSGO;

    public override void Start()
    {
        playerGO = IGameObject.Find("SK_MainCharacter");
        player = playerGO.GetComponent<PlayerScript>();
        initialPos = attachedGameObject.transform.Position;

        gameManager = IGameObject.Find("GameManager").GetComponent<GameManager>();

        attachedGameObject.animator.Play("Walk");
        attachedGameObject.animator.Blend = true;
        attachedGameObject.animator.TransitionTime = 0.3f;

        acidSpitPSGO = attachedGameObject.FindInChildren("AcidSpitPS")?.GetComponent<IParticleSystem>();
        tailAttackPSGO = attachedGameObject.FindInChildren("TailAttackPS")?.GetComponent<IParticleSystem>();
        deathPSGO = attachedGameObject.FindInChildren("DeathPS")?.GetComponent<IParticleSystem>();
    }

    public override void Update()
    {
        attachedGameObject.animator.UpdateAnimation();

        if (currentState == States.Dead)
        {
            //destroyTimer += Time.deltaTime;
            //if (destroyTimer >= destroyCooldown)
            //    attachedGameObject.Destroy();

            return;
        }

        if (attachedGameObject.transform.ComponentCheck())
        {
            //Set the director vector and distance to the player
            playerDistance = Vector3.Distance(playerGO.transform.Position, attachedGameObject.transform.Position);

            UpdateFSM();
            DoStateBehaviour();
        }

        DebugDraw();
    }

    void UpdateFSM()
    {
        if (life <= 0)
        {
            currentState = States.Dead;
            return;
        }

        if (!detected && playerDistance < detectedRange)
        {
            detected = true;
            currentState = States.Chase;
            //Debug.Log("White Xenomorph switched to Chase");
        }

        if (detected)
        {
            CheckIsClose();

            if (currentAttack == WhiteXenomorphAttacks.None)
            {
                attackTimer += Time.deltaTime;
                attachedGameObject.animator.Play("Walk");
            }

            CheckIsMaxRangeStopChasing();

            if (currentAttack == WhiteXenomorphAttacks.None && attackTimer >= attackCooldown)
            {
                currentState = States.Attack;
                //Debug.Log("White Xenomorph switched to Attack");
            }

            if (playerDistance > maxChasingRange && currentState != States.Attack)
            {
                detected = false;
                currentState = States.Patrol;
                //Debug.Log("White Xenomorph switched to Patrol");
            }
        }
    }

    private void CheckIsClose()
    {
        if (playerDistance < isCloseRange && !isClose)
        {
            isClose = true;
            //Debug.Log("Player is now CLOSE");
        }
        else if (playerDistance >= isCloseRange && isClose)
        {
            isClose = false;
            //Debug.Log("Player is now FAR");
        }
    }

    private void CheckIsMaxRangeStopChasing()
    {
        if (playerDistance <= maxRangeStopChasing && currentAttack == WhiteXenomorphAttacks.None &&
            currentState != States.Idle)
        {
            currentState = States.Idle;
            //Debug.Log("Player is INSIDE maxRangeStopChasing");
        }
        else if (playerDistance > maxRangeStopChasing && currentAttack == WhiteXenomorphAttacks.None &&
                 currentState != States.Chase)
        {
            currentState = States.Chase;
            //Debug.Log("Player is OUTSIDE maxRangeStopChasing");
        }
    }

    void DoStateBehaviour()
    {
        switch (currentState)
        {
            case States.Idle:
                return;
            case States.Attack:
                player.isFighting = true;
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                ChooseAttack();
                switch (currentAttack)
                {
                    case WhiteXenomorphAttacks.ClawAttack:
                        ClawAttack();
                        break;
                    case WhiteXenomorphAttacks.TailTrip:
                        TailTrip();
                        break;
                    default:
                        break;
                }
                break;
            case States.Chase:
                player.isFighting = true;
                attachedGameObject.transform.LookAt2D(playerGO.transform.Position);
                attachedGameObject.transform.Translate(attachedGameObject.transform.Forward * movementSpeed * Time.deltaTime);
                break;
            case States.Patrol:
                Patrol();
                break;
            case States.Dead:
                Dead();
                break;
            default:
                break;
        }
    }

    private void ChooseAttack()
    {
        if (currentAttack == WhiteXenomorphAttacks.None)
        {
            if (isClose)
            {
                currentAttack = WhiteXenomorphAttacks.ClawAttack;
                attachedGameObject.animator.Play("ClawAttack");

                tailAttackPSGO.Play();
            }
            else
            {
                currentAttack = WhiteXenomorphAttacks.TailTrip;
                attachedGameObject.animator.Play("TailTrip");

                acidSpitPSGO.Play();
            }
            //Debug.Log("WhiteXenomorph current attack: " + currentAttack);
        }
    }

    private void ClawAttack()
    {
        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            ResetState();
        }
    }

    private void TailTrip()
    {
        if (attachedGameObject.animator.CurrentAnimHasFinished)
        {
            ResetState();
        }
    }

    private void Patrol()
    {
        attachedGameObject.animator.Play("Walk");

        if (currentState != lastState)
        {
            lastState = currentState;
            goingToRoundPos = true;
        }

        roundProgress += Time.deltaTime * patrolSpeed;
        if (roundProgress > 360.0f) roundProgress -= 360.0f;

        Vector3 roundPos = initialPos +
                           Vector3.right * (float)Math.Cos(roundProgress * Math.PI / 180.0f) * patrolRange +
                           Vector3.forward * (float)Math.Sin(roundProgress * Math.PI / 180.0f) * patrolRange;

        attachedGameObject.transform.LookAt2D(roundPos);
        if (!goingToRoundPos)
        {
            MoveTo(roundPos);
        }
        else
        {
            goingToRoundPos = !MoveTo(roundPos);
        }
    }

    private void Dead()
    {
        if (!isDead)
        {
            attachedGameObject.animator.Play("Death");
            isDead = true;
            player.shieldKillCounter++;
            // add player biomass
            deathPSGO.Play();
        }
    }

    private void ResetState()
    {
        attackTimer = 0.0f;
        currentAttack = WhiteXenomorphAttacks.None;
        currentState = States.Chase;
    }

    public void ReduceLife() //temporary function for the hardcoding of collisions
    {
        life -= player.totalDamage;
        if (life < 0) life = 0;
    }

    public void ReduceLifeExplosion()
    {
        life -= player.GrenadeLauncher.damage;
        if (life < 0) life = 0;
    }

    private bool MoveTo(Vector3 targetPosition)
    {
        //Return true if arrived at destination
        if (Vector3.Distance(attachedGameObject.transform.Position, targetPosition) < 0.5f) return true;

        Vector3 dirVector = (targetPosition - attachedGameObject.transform.Position).Normalize();
        attachedGameObject.transform.Translate(dirVector * movementSpeed * Time.deltaTime);

        return false;
    }

    private void DebugDraw()
    {
        //Draw debug ranges
        if (gameManager.colliderRender)
        {
            if (!detected)
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, detectedRange, new Vector3(1.0f, 0.8f, 0.0f)); //Yellow
            }
            else
            {
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, isCloseRange, new Vector3(1.0f, 0.0f, 0.0f)); //Red
                Debug.DrawWireCircle(attachedGameObject.transform.Position + Vector3.up * 4, maxChasingRange, new Vector3(1.0f, 0.0f, 1.0f)); //Purple
            }
        }
    }
}`, 'cpp');}
// Wait for the window to fully load before initializing editors
window.onload = function() {
            initializeEditors();
            setTimeout(function() {
                document.querySelectorAll('.editor-container').forEach(container => {
                    const event = new Event('resize');
                    window.dispatchEvent(event);
                });
            }, 100);
        };
    });
</script>
