<!DOCTYPE HTML>
<!--
	Helios by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>Code - Lluis González</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<link rel="stylesheet" href="assets/css/personal.css" />
	<noscript>
		<link rel="stylesheet" href="assets/css/noscript.css" />
	</noscript>
	<link rel="shortcut icon" type="image/png" href="images/icons/favicon.png">
</head>

<body style="align-items: center;">
	<div>

		<!-- Header -->
		<div id="header">

			<!-- Inner -->
			<header>
				<video autoplay muted loop id="video-background"
					style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1;">
					<source src="images/videos/banner.mp4" type="video/mp4">
					Your browser does not support the video tag.
				</video>
				<div id="video-overlay"
					style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 2;">
				</div>
			</header>


			<!-- Nav -->
			<nav id="nav" style="z-index: 20;">
				<ul>
					<li><a href="index.html">Home</a></li>
					<li>
						<a href="teams.html">Teams</a>
						<ul>
							<li><a href="ArtTeam.html">Art</a></li>
							<li><a href="CodeTeam.html">Code</a></li>
							<li><a href="DesignTeam.html">Design</a></li>
							<li><a href="LeadsTeam.html">Leads</a></li>
						</ul>
					</li>
					<li><a href="engine.html">Engine</a></li>
					<li><a href="production.html">Production</a></li>
					<li><a href="postmortem.html">Post-Mortem</a></li>
					<li><a href="https://github.com/Shadow-Wizard-Games/TheOneEngine" target="_blank">Source Code</a>
					</li>
				</ul>
			</nav>
		</div>

		<!-- Main -->
		<div class="bio-body">
            <div class="bio-container">
                <h1 class="bio-name">Lluis González</h1>
                <img src="images/members/code/lluis.jpg" alt="Profile Picture" class="bio-profile-pic">
                <p class="bio-description">
                    Hi, I’m Luis González, a 20 year old student in Video Game Design and Development in CITM-UPC. I was born in Barcelona, but I live in a far away town :) 
                </p>
				<div class="member-links">
					<a href="https://github.com/punto16" target="_blank" class="link-icon"><i
							class="fab fa-github"></i></a>
					<a href="https://linkedin.com/in/luis-gonzález-ramírez-485a562b4" target="_blank"
						class="link-icon"><i class="fab fa-linkedin"></i></a>
				</div>
            </div>
        </div>
        <hr />
      
        <div style="display: flex; justify-content: center; padding-top: 20px; align-items: center; flex-direction: column;">
            <div>
                <div>
                    <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center;">Background</h2>
                    <h3 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; text-align: center; font-size: 32px;">
                        About Me
                    </h3>
                    <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 80px; padding-right: 80px; text-align: center; font-size: 24px;">
                        I’m Luis González, right now I’m a Video Game developer student at CITM-UPC. 
                        My goals are to be part of the development of an Indie game, an AAA game and, at some point, develop my own 
                        Video Game on my own. I also would like to develop my own 2D Engine on my own to test my abilities and, maybe, 
                        use it for the Video Game I want to develop on my own.
                        <br>
                        <br>
                        Some of my most relevant achievements are being part of this Video Game development (Alien: Nemesis), 
                        the development of my own 3D Engine (Mantel Engine) and being part of the development of a 2D Tactical RPG Video Game (Breaking Cats).
                    </p>
                </div>
                <hr />
                <div style="display:block; align-items: center; justify-content: center;">
                    <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center; padding-top: 20px;">Project Overview</h2>
                    <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 60px; padding-right: 60px; text-align: center; font-size: 24px; padding-top: 20px;">
                        For this project I had the role of Developer in the Code Team. 
                        My job was to help in the process of the development of the game 
                        and the engine, for more detail seek Main Tasks.
                    </p>
                    <h3 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; font-size: 32px; text-align: center;">
                        Main Tasks
                    </h3>
                    <div style="display:flex; flex-direction: row; justify-content: center; flex-wrap: wrap;">
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Development of Canvas</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            Update of Canvas: Canvas prints in the Screen all the UiElements that it has
                            There are the following UiElements types:
                            <div style="display: flex; flex-direction: row; justify-content: space-evenly; flex-wrap: wrap;">
                                <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">ImageUI</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">ButtonImageUI</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">CheckerUI</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">SliderUI</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">TextUI</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Flickering FX</p>
                            </div>
                            <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; padding-top: 20px; font-size: 18px;">All ImGui Panel Inspector in order to edit variables, Add Canvas, Remove it, etc.</p>
                            <img src="images/bio/Lluis/1. Canvas.gif" style="object-fit: fill; height:460px; width: 700px; padding-top: 20px;" alt="" />
                            <h4 style="padding-top: 10px; color:rgb(238, 164, 130); font-size: 24px; text-align: center; text-decoration: underline;">Difficulties</h4>
                            <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; padding-top: 20px; font-size: 18px;">
                                Some difficulties appeared on selecting the section of the images, that changed the scale of the image.
                                Other challenges include the SliderUI having an excessive number of editable options, which affects readability. Modifying the ImGui Panel Inspector for the Slider to 
                                enhance readability is advisable.</p>
                            </p>
                        
                        
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Development of Canvas</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            We had all the art, sprites and designs for the menus, so it was time to implement them in the game.
                            I created a new scene called HUD_Scene to advance all UI progress there. 
                            <br>
                            <br>
                            I created the canvases and 
                            UIElements for all the menus and, then, I scripted them to be able
                            for the player to navigate through the different options. All ImGui Panel Inspector in order to edit variables, Add Canvas, Remove it, etc. <br> Also scripted the hud to match abilities cooldowns with player, their current Loadout, etc.</p>
                            <img src="images/bio/Lluis/2. ImageUI.gif" style="object-fit: fill; height:600px; width: 700px; padding-top: 20px;" alt="" />
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Hierarchy Utilities</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            <div style="display: flex; flex-direction: column; justify-content: space-evenly; flex-wrap: wrap;">
                                <li style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Overhaul Transform Component, Quaternions, ImGuizmo</li>
                                    <li style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Redesign Camera Component</li>
                                    <li style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Frustum Culling</li>
                                    <li style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Raycasting</li>
                            </div>
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Collision System</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            <div style="display: flex; flex-direction: column; justify-content: space-evenly; flex-wrap: wrap;">
                                <li style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Add colliders so player won't trespass walls</li>
                                    <li style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Add collider type such as rect and circle</li>
                                    <li style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Add collision type such as Player, Enemy and Wall</li>
                                    <li style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Variables to ImGui Panel Inspector</li>
                            </div>
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Prepare Audio Engine</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            I fixed and removed the hardcoded code in Audio Engine to make aviable its use from different parts of the Engine
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Implementation of Audio Manager in Engine</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            I  helped on the implementation of the Audio Manager that manages the Audio Engine functions
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Scrum Master</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            I've been Scrum Master twice involving:
                            <div style="display: flex; flex-direction: row; justify-content: space-evenly; flex-wrap: wrap;">
                                <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Planning</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Organization</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Meetings</p>
                            </div>
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Temporary Code Lead</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            First time I was Scrum Master, half of the code team including the Code Lead left and I took the role of Temporary Code Lead to release the Vertical Slice Build 1.5v
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Heal & Adrenaline Particles</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            Particle implementations including:
                            <div style="display: flex; flex-direction: row; justify-content: space-evenly; flex-wrap: wrap;">
                                <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Particles of Hit for each enemy</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Particles of Death for each enemy</p>
                            </div>
                        </p>
                        </div>
                        <div class="bio-container" style="width: 800px;
                        position: relative;
                        margin: 40px;">
                        <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; color:rgb(250, 236, 156); text-decoration: underline; font-size: 32px; text-align: center;">Hit & Death Particles</h4>
                        <p style="padding: 0px 0px 0 0; text-align: center; color: white; padding-left: 10px; padding-right: 10px; font-size: 18px;">
                            Particle implementations including:
                            <div style="display: flex; flex-direction: row; justify-content: space-evenly; flex-wrap: wrap;">
                                <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Particles of Heal for player</p>
                                    <p style="font-size: 18px; color: rgb(9, 255, 0); font-weight: bold; margin: 10px; text-wrap: nowrap;">Particles of Adrenaline Rush for player</p>
                            </div>
                        </p>
                        </div>
                    </div>
                </div>
                <hr>
                <h2 style="font-family: Alien Invader; color: rgb(0, 252, 0); text-align: center; padding-top: 20px; padding-bottom: 40px;">Work Demos</h2>
                    <div style="display:flex; flex-direction: row; justify-content: center; flex-wrap: wrap;">
                        <div style="width: 60%; /* Adjust the width as needed */
                        height: auto;
                        margin-bottom: 20px;
                        box-shadow: 0 0px 20px rgba(0, 255, 0, 1.0); /* Ensure relative positioning */">
                            <div style="display: flex; flex-direction: column;">
                            <h4 style="font-family: Alien Invader; color: white; padding-top: 40px; padding-bottom: 20px; color:rgb(250, 236, 156); font-size: 32px; text-align: center;">In-Game Canvas</h4>
                            <video autoplay muted loop id="video-background"
                            style=" height: 500px; object-fit: fill; z-index: 1; border-radius: 5%; padding-bottom: 20px;">
                            <source src="images/bio/Lluis/Canvas2.mp4" type="video/mp4">
                            Your browser does not support the video tag.
				            </video>
                        </div>
                    </div>
                    </div>
                    <div style="display:flex; flex-direction: row; justify-content: center; flex-wrap: wrap;">
                        <!-- Slideshow container -->
                        <div class="slideshow-container" id="slideshow1" style="width: 60%;">
                            <h4 style="font-family: Alien Invader; color: white; padding-top: 36px; padding-bottom: 20px; color: rgb(242, 250, 169); font-size: 24px; text-align: center;">
                                Additional UI Elements</h4>
                            <!-- Full-width images with number and caption text -->
                            <div class="weaponassets fade">
                                <div class="numbertext">1 / 5</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Lluis/2. ImageUI.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Image UI</div>
                                </div>
                                
                            </div>
                            <div class="weaponassets fade">
                                <div class="numbertext">2 / 5</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Lluis/3. ButtonImageU.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Button Image UI</div>
                                </div>
                                
                            </div>
                            <div class="weaponassets fade">
                                <div class="numbertext">3 / 5</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Lluis/4. SliderUI.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Slider UI</div>
                                </div>
                                
                            </div>
                            <div class="weaponassets fade">
                                <div class="numbertext">4 / 5</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Lluis/5. CheckerUI.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Checker UI</div>
                                </div>
                                
                            </div>
                            <div class="weaponassets fade">
                                <div class="numbertext">5 / 5</div>
                                <div class="model-viewer-container">
                                    <img src="images/bio/Lluis/6. TextUI.gif" style="object-fit: fill; border-radius: 5%; height:500px; width:900px">
                                </div>
                                <div style="display: flex; flex-direction: row; justify-content: center;">
                                    <div class="text">Text UI</div>
                                </div>
                                
                            </div>
                        
                            <!-- Next and previous buttons -->
                            <div style="display: flex; flex-direction: row; justify-content: space-between;">
                                <a class="prev" onclick="plusSlides('slideshow1', -1)">&#10094;</a>
                                <a class="next" onclick="plusSlides('slideshow1', 1)">&#10095;</a>
                            </div>
                            
                        </div>
                    </div>

                </div>
                    
                    
            </div>
        </div>  
        <hr>  

        
        
            
		<!-- Footer -->
		<div id="footer">
			<div class="container">

				<div class="row">
					<div class="col-12">

						<!-- Contact -->
						<section class="contact">
							<header>
								<h3 style="color: rgb(0, 255, 0);">Want more?</h3>
							</header>
							<p style="color: white;">Check us out below!</p>
							<ul class="icons">
								<li><a href="https://x.com/ShadowWizGames" target="_blank"
										class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>

								<li><a href="https://www.instagram.com/shadow.wizard.games/" target="_blank"
										class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>

								<li><a href="https://shadowwizardgames.tumblr.com/" target="_blank"
										class="icon brands fa-tumblr"><span class="label">Tumblr</span></a>
								</li>
								<li><a href="mailto:shadow.wizard.m.games@gmail.com" class="icon fa-envelope"><span
											class="label">Email</span></a>
							</ul>
						</section>

						<!-- Copyright -->
						<div class="copyright">
							<ul class="menu">
								<li>&copy; Alien: Nemesis - Shadow Wizard Games. All rights reserved.</li>
							</ul>
						</div>
					</div>

				</div>
			</div>
		</div>

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/jquery.dropotron.min.js"></script>
	<script src="assets/js/jquery.scrolly.min.js"></script>
	<script src="assets/js/jquery.scrollex.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>
	<script src="assets/js/Code.js"></script>
	<script src="assets/js/playbuttondelay.js"></script>
    <script>
        function openTab(evt, tabName) {
            // Declare all variables
            var i, tabcontent, tablinks;
    
            // Get all elements with class="bio-tab-content" and hide them
            tabcontent = document.getElementsByClassName("bio-tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove('active');
            }
    
            // Get all elements with class="bio-tab" and remove the class "active"
            tablinks = document.getElementsByClassName("bio-tab");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
    
            // Show the current tab, and add an "active" class to the button that opened the tab
            document.getElementById(tabName).style.display = "block";
            document.getElementById(tabName).classList.add('active');
            evt.currentTarget.className += " active";
        }
    </script>
    <script>
                        // Define an object to store slide indexes for each slideshow
            let slideIndexes = {};

            // Initialize slide indexes for each slideshow
            function initSlideIndexes() {
                let slideshowContainers = document.querySelectorAll('.slideshow-container');
                slideshowContainers.forEach((container, index) => {
                    slideIndexes['slideshow' + (index + 1)] = 1; // Initialize slide index to 1 for each slideshow
                });
            }

            function showSlides(slideshowIndex, n) {
                let slides = document.querySelectorAll('#' + slideshowIndex + ' .weaponassets');
                if (n > slides.length) { slideIndexes[slideshowIndex] = 1; }
                if (n < 1) { slideIndexes[slideshowIndex] = slides.length; }
                slides.forEach((slide, index) => {
                    slide.style.display = "none";
                });
                slides[slideIndexes[slideshowIndex] - 1].style.display = "block";

                // Update the slide index text
                let slideIndexText = document.querySelector('#' + slideshowIndex + ' .numbertext');
                if (slideIndexText) {
                    slideIndexText.textContent = slideIndexes[slideshowIndex] + ' / ' + slides.length;
                }
            }

            // Change slide for a specific slideshow
            function plusSlides(slideshowIndex, n) {
                showSlides(slideshowIndex, slideIndexes[slideshowIndex] += n);
            }

            // Set up slide indexes for all slideshows
            initSlideIndexes();

            // Show the initial slides for all slideshows
            Object.keys(slideIndexes).forEach(slideshowIndex => {
                showSlides(slideshowIndex, slideIndexes[slideshowIndex]);
            });
    </script>

</body>

</html>

<script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.5.0/model-viewer.min.js"></script>
<!-- Monaco Editor -->
<script src="https://cdn.jsdelivr.net/npm/monaco-editor/min/vs/loader.js"></script>
<script>
    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor/min/vs' }});
    require(['vs/editor/editor.main'], function() {
        function createEditor(id, value, language) {
            const container = document.getElementById(id);
            const editor = monaco.editor.create(container, {
                value: value,
                language: language,
                theme: 'vs-dark',
                readOnly: true // Set editor to read-only
            });

            // Inject CSS rules to round the corners of the editor
            const styleElement = document.createElement('style');
            styleElement.innerHTML = `
                .monaco-editor .overflow-guard,
                .monaco-editor .monaco-scrollable-element {
                    border-radius: 10px;
                    overflow: hidden !important;
                    border: none !important; /* Ensure no border */
                }
            `;
            editor._domElement.appendChild(styleElement); // Append style to the editor's DOM

            // Adjust the layout to fit the container size
            function resizeEditor() {
                const containerRect = container.getBoundingClientRect();
                editor.layout({
                    width: containerRect.width,
                    height: containerRect.height
                });
            }

            // Trigger layout adjustment after editor creation and after a small delay
            resizeEditor();
            setTimeout(resizeEditor, 100); // Delay to ensure correct dimensions

            // Adjust layout on window resize
            window.addEventListener('resize', resizeEditor);
        }

        // Initialize editors
        function initializeEditors() {
        // Editor 1
        createEditor('editor1', `#include "Emmiter.h"
#include <map>
#include <GL/glew.h>
#include <glm/gtx/norm.hpp>

#include "ParticleSystem.h"

Emmiter::Emmiter(ParticleSystem* owner)
{
	this->owner = owner;

	delay = 0;
	maxParticles = 100;
	duration = 10;
	lifetime = 0;
	isLooping = true;
	isON = true;
	isGlobal = true;

	AddModule(SpawnEmmiterModule::CONSTANT);

	AddModule(RenderEmmiterModule::BILLBOARD);

	AddModule(InitializeEmmiterModule::SET_DIRECTION);
	AddModule(InitializeEmmiterModule::SET_SPEED);

	RestartParticlePool();
}

Emmiter::Emmiter(ParticleSystem* owner, Emmiter* ref)
{
	this->owner = owner;

	delay = ref->delay;
	maxParticles = ref->maxParticles;
	duration = ref->duration;
	lifetime = ref->lifetime;
	isLooping = ref->isLooping;
	isON = ref->isON;
	isGlobal = ref->isGlobal;

	// TO-DO
	AddModule(ref->spawnModule.get());

	for (const auto& initRef : ref->initializeModules) {
		AddModule(initRef.get());
	}

	for (const auto& updateRef : ref->updateModules) {
		AddModule(updateRef.get());
	}

	AddModule(ref->renderModule.get());

	RestartParticlePool();
}

Emmiter::~Emmiter()
{
}

void Emmiter::Start()
{
	lifetime = 0;
	while (!usingParticlesIDs.empty()) {
		freeParticlesIDs.push(usingParticlesIDs[usingParticlesIDs.size() - 1]);
		usingParticlesIDs.pop_back();
	}

	if (spawnModule) {
		spawnModule->Reset();
	}

	isON = true;

	RestartParticlePool();
}

void Emmiter::Update(double dt)
{
	if (!isON) return;

	lifetime += dt;

	if (lifetime < delay) return;

	if (lifetime > duration + delay && usingParticlesIDs.empty() && !isLooping) {
		isON = false;
	}

	if (lifetime < duration + delay || isLooping) {
		if (spawnModule && !owner->HasToEnd()) {
			spawnModule->Update(dt);
		}
	}

	for (auto i = updateModules.begin(); i != updateModules.end(); ++i) {
		for (auto j = usingParticlesIDs.begin(); j != usingParticlesIDs.end(); ++j) {
			(*i)->Update(dt, particles[*j].get());
		}
	}

	std::vector<std::vector<int>::iterator> particlesToFree;

	for (auto i = usingParticlesIDs.begin(); i != usingParticlesIDs.end(); ++i) {
		particles[*i]->Update(dt);
		if (particles[*i]->lifetime > particles[*i]->duration) {
			particlesToFree.push_back(i);
		}
	}

	for (auto i = particlesToFree.rbegin(); i != particlesToFree.rend(); ++i) {
		freeParticlesIDs.push(*(*i));
		usingParticlesIDs.erase(*i);
	}
}

void Emmiter::Render(Camera* camera)
{
	// sort particles by distance to the camera
	std::vector<Particle*> particlesToRender;
	for (auto i = usingParticlesIDs.begin(); i != usingParticlesIDs.end(); ++i) {
		particlesToRender.push_back(particles[(*i)].get());
	}

	std::multimap<float, Particle*> sortedParticlesToRender;
	for (auto i = particlesToRender.begin(); i != particlesToRender.end(); ++i) {
		float particleZ;
		if (isGlobal) {
			particleZ = glm::length((*i)->position - camera->GetContainerGO()->GetComponent<Transform>()->GetPosition());
		}
		else {
			particleZ = glm::length((*i)->position - camera->GetContainerGO()->GetComponent<Transform>()->GetPosition());
		}
		sortedParticlesToRender.insert(std::pair<float, Particle*>(particleZ, (*i)));
	}

	if (renderModule) {
		for (auto i = sortedParticlesToRender.rbegin(); i != sortedParticlesToRender.rend(); ++i) {
			renderModule->Update(i->second, camera);
		}
	}
}

void Emmiter::SpawnParticles(int amount)
{
	for (int i = 0; i < amount; ++i) {
		if (!freeParticlesIDs.empty()) {
			int spawnedParticleID = freeParticlesIDs.front();
			usingParticlesIDs.push_back(spawnedParticleID);
			freeParticlesIDs.pop();
			InitializeParticle(particles[spawnedParticleID].get());
		}
	}
}

void Emmiter::RestartParticlePool()
{
	usingParticlesIDs.clear();

	while (!freeParticlesIDs.empty()) {
		freeParticlesIDs.pop();
	}

	for (int i = 0; i < maxParticles; ++i) {
		freeParticlesIDs.push(i);
	}

	particles.clear();

	for (int i = 0; i < maxParticles; ++i) {
		particles.push_back(std::move(std::make_unique<Particle>()));
	}

	particles.shrink_to_fit();
}

void Emmiter::InitializeParticle(Particle* particle)
{
	particle->SetDuration(spawnModule->duration);

	particle->ResetAttributes();

	if (isGlobal) {
		particle->position += (vec3)owner->GetTransform()->GetGlobalTransform()[3];
	}

	for (auto i = initializeModules.begin(); i != initializeModules.end(); ++i) {
		(*i)->Initialize(particle);
	}
}

void Emmiter::ClearModules()
{
	spawnModule.reset();
	initializeModules.clear();
	updateModules.clear();
	renderModule.reset();
}

SpawnEmmiterModule* Emmiter::AddModule(SpawnEmmiterModule::SpawnEmmiterModuleType type)
{
	SpawnEmmiterModule* newModule = nullptr;
	switch (type)
	{
	case SpawnEmmiterModule::CONSTANT:
		spawnModule = std::make_unique<ConstantSpawnRate>(this);
		newModule = spawnModule.get();
		break;
	case SpawnEmmiterModule::SINGLE_BURST:
		spawnModule = std::make_unique<SingleBurstSpawn>(this);
		newModule = spawnModule.get();
		break;
	case SpawnEmmiterModule::CONSTANT_BURST:
		spawnModule = std::make_unique<ConstantBurstSpawn>(this);
		newModule = spawnModule.get();
		break;
	default:
		break;
	}
	return newModule;
}

InitializeEmmiterModule* Emmiter::AddModule(InitializeEmmiterModule::InitializeEmmiterModuleType type)
{
	InitializeEmmiterModule* newModule = nullptr;
	switch (type)
	{
	case InitializeEmmiterModule::SET_SPEED:
		initializeModules.push_back(std::move(std::make_unique<SetSpeed>(this)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	case InitializeEmmiterModule::SET_COLOR:
		initializeModules.push_back(std::move(std::make_unique<SetColor>(this)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	case InitializeEmmiterModule::SET_SCALE:
		initializeModules.push_back(std::move(std::make_unique<SetScale>(this)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	case InitializeEmmiterModule::SET_OFFSET:
		initializeModules.push_back(std::move(std::make_unique<SetOffset>(this)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	case InitializeEmmiterModule::SET_DIRECTION:
		initializeModules.push_back(std::move(std::make_unique<SetDirection>(this)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	default:
		break;
	}
	return newModule;
}

UpdateEmmiterModule* Emmiter::AddModule(UpdateEmmiterModule::UpdateEmmiterModuleType type)
{
	UpdateEmmiterModule* newModule = nullptr;
	switch (type)
	{
	case UpdateEmmiterModule::ACCELERATION:
		updateModules.push_back(std::move(std::make_unique<AccelerationUpdate>(this)));
		newModule = updateModules[updateModules.size() - 1].get();
		break;
	case UpdateEmmiterModule::COLOR_OVER_LIFE:
		updateModules.push_back(std::move(std::make_unique<ColorOverLifeUpdate>(this)));
		newModule = updateModules[updateModules.size() - 1].get();
		break;
	case UpdateEmmiterModule::SCALE_OVER_LIFE:
		updateModules.push_back(std::move(std::make_unique<ScaleOverLifeUpdate>(this)));
		newModule = updateModules[updateModules.size() - 1].get();
		break;

	default:
		break;
	}
	return newModule;
}

RenderEmmiterModule* Emmiter::AddModule(RenderEmmiterModule::RenderEmmiterModuleType type)
{
	RenderEmmiterModule* newModule = nullptr;
	switch (type)
	{
	case RenderEmmiterModule::BILLBOARD:
		renderModule = std::make_unique<BillboardRender>(this);
		newModule = renderModule.get();
		break;
	default:
		break;
	}
	return newModule;
}

SpawnEmmiterModule* Emmiter::AddModule(SpawnEmmiterModule* ref)
{
	SpawnEmmiterModule* newModule = nullptr;
	switch (ref->type)
	{
	case SpawnEmmiterModule::CONSTANT:
		spawnModule = std::make_unique<ConstantSpawnRate>(this, (ConstantSpawnRate*)ref);
		newModule = spawnModule.get();
		break;
	case SpawnEmmiterModule::SINGLE_BURST:
		spawnModule = std::make_unique<SingleBurstSpawn>(this, (SingleBurstSpawn*)ref);
		newModule = spawnModule.get();
		break;
	case SpawnEmmiterModule::CONSTANT_BURST:
		spawnModule = std::make_unique<ConstantBurstSpawn>(this, (ConstantBurstSpawn*)ref);
		newModule = spawnModule.get();
		break;
	default:
		break;
	}
	return newModule;
}

InitializeEmmiterModule* Emmiter::AddModule(InitializeEmmiterModule* ref)
{
	InitializeEmmiterModule* newModule = nullptr;
	switch (ref->type)
	{
	case InitializeEmmiterModule::SET_SPEED:
		initializeModules.push_back(std::move(std::make_unique<SetSpeed>(this, (SetSpeed*)ref)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	case InitializeEmmiterModule::SET_COLOR:
		initializeModules.push_back(std::move(std::make_unique<SetColor>(this, (SetColor*)ref)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	case InitializeEmmiterModule::SET_SCALE:
		initializeModules.push_back(std::move(std::make_unique<SetScale>(this, (SetScale*)ref)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	case InitializeEmmiterModule::SET_OFFSET:
		initializeModules.push_back(std::move(std::make_unique<SetOffset>(this, (SetOffset*)ref)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	case InitializeEmmiterModule::SET_DIRECTION:
		initializeModules.push_back(std::move(std::make_unique<SetDirection>(this, (SetDirection*)ref)));
		newModule = initializeModules[initializeModules.size() - 1].get();
		break;
	default:
		break;
	}
	return newModule;
}

UpdateEmmiterModule* Emmiter::AddModule(UpdateEmmiterModule* ref)
{
	UpdateEmmiterModule* newModule = nullptr;
	switch (ref->type)
	{
	case UpdateEmmiterModule::ACCELERATION:
		updateModules.push_back(std::move(std::make_unique<AccelerationUpdate>(this, (AccelerationUpdate*)ref)));
		newModule = updateModules[updateModules.size() - 1].get();
		break;
	case UpdateEmmiterModule::COLOR_OVER_LIFE:
		updateModules.push_back(std::move(std::make_unique<ColorOverLifeUpdate>(this, (ColorOverLifeUpdate*)ref)));
		newModule = updateModules[updateModules.size() - 1].get();
		break;
		case UpdateEmmiterModule::SCALE_OVER_LIFE:
			updateModules.push_back(std::move(std::make_unique<ScaleOverLifeUpdate>(this, (ScaleOverLifeUpdate*)ref)));
			newModule = updateModules[updateModules.size() - 1].get();
			break;

	default:
		break;
	}
	return newModule;
}

RenderEmmiterModule* Emmiter::AddModule(RenderEmmiterModule* ref)
{
	RenderEmmiterModule* newModule = nullptr;
	switch (ref->type)
	{
	case RenderEmmiterModule::BILLBOARD:
		renderModule = std::make_unique<BillboardRender>(this, (BillboardRender*)ref);
		newModule = renderModule.get();
		break;
	default:
		break;
	}
	return newModule;
}

json Emmiter::SaveEmmiter()
{
	json emmiterJSON;

	if (spawnModule != nullptr)
	{
		json spawnJSON;

		spawnJSON.push_back(spawnModule->SaveModule());

		emmiterJSON["SpawnModule"] = spawnJSON;
	}

	if (!initializeModules.empty())
	{
		json initializeJSON;

		for (const auto& initModule : initializeModules)
		{
			initializeJSON.push_back(initModule->SaveModule());
		}

		emmiterJSON["InitializeModules"] = initializeJSON;
	}

	if (!updateModules.empty())
	{
		json updateJSON;

		for (const auto& updateModule : updateModules)
		{
			updateJSON.push_back(updateModule->SaveModule());
		}

		emmiterJSON["UpdateModules"] = updateJSON;
	}

	if (renderModule != nullptr)
	{
		json renderJSON;

		renderJSON.push_back(renderModule->SaveModule());

		emmiterJSON["RenderModule"] = renderJSON;
	}

	emmiterJSON["MaxParticles"] = maxParticles;
	emmiterJSON["Duration"] = duration;
	emmiterJSON["Lifetime"] = lifetime;
	emmiterJSON["Delay"] = delay;
	emmiterJSON["IsLooping"] = isLooping;

	return emmiterJSON;
}

void Emmiter::LoadEmmiter(const json& emmiterJSON)
{
	// Load basic properties
	if (emmiterJSON.contains("MaxParticles"))
	{
		maxParticles = emmiterJSON["MaxParticles"];
	}

	if (emmiterJSON.contains("Duration"))
	{
		duration = emmiterJSON["Duration"];
	}

	if (emmiterJSON.contains("Lifetime"))
	{
		lifetime = emmiterJSON["Lifetime"];
	}

	if (emmiterJSON.contains("Delay"))
	{
		delay = emmiterJSON["Delay"];
	}

	if (emmiterJSON.contains("IsLooping"))
	{
		isLooping = emmiterJSON["IsLooping"];
	}

	if (emmiterJSON.contains("SpawnModule"))
	{
		auto spawnM = AddModule((SpawnEmmiterModule::SpawnEmmiterModuleType)emmiterJSON["SpawnModule"][0]["Type"]);
		spawnM->LoadModule(emmiterJSON["SpawnModule"][0]);
	}

	if (emmiterJSON.contains("InitializeModules"))
	{
		const json& initializeJSON = emmiterJSON["InitializeModules"];

		for (const auto& initJSON : initializeJSON)
		{
			auto initM = AddModule((InitializeEmmiterModule::InitializeEmmiterModuleType)initJSON["Type"]);
			initM->LoadModule(initJSON);
		}
		
	}

	if (emmiterJSON.contains("UpdateModules"))
	{
		const json& updateJSON = emmiterJSON["UpdateModules"];

		for (const auto& uJSON : updateJSON)
		{
			auto updateM = AddModule((UpdateEmmiterModule::UpdateEmmiterModuleType)uJSON["Type"]);
			updateM->LoadModule(uJSON);
		}
	}

	if (emmiterJSON.contains("RenderModule"))
	{
		auto spawnM = AddModule((RenderEmmiterModule::RenderEmmiterModuleType)emmiterJSON["RenderModule"][0]["Type"]);
		spawnM->LoadModule(emmiterJSON["RenderModule"][0]);
	}

	RestartParticlePool();
}
`, 'cpp');

        // Editor 2
        createEditor('editor2', `#include "ParticleSystem.h"
#include "GameObject.h"
#include "SingleOrRandom.h"
#include "EngineCore.h"
#include <ostream>
#include <istream>
#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;

ParticleSystem::ParticleSystem(std::shared_ptr<GameObject> containerGO) : Component(containerGO, ComponentType::ParticleSystem)
{
	this->transform = containerGO.get()->GetComponent<Transform>();

	if (transform == nullptr)
	{
		LOG(LogType::LOG_ERROR, "GameObject Container invalid!");
	}

	startON = true;

	isON = startON;
	hasToEnd = false;
	AddEmmiter();
}

ParticleSystem::ParticleSystem(std::shared_ptr<GameObject> containerGO, ParticleSystem* ref) : Component(containerGO, ComponentType::ParticleSystem),
isON(ref->isON)
{
	this->transform = containerGO.get()->GetComponent<Transform>();

	if (transform == nullptr)
	{
		LOG(LogType::LOG_ERROR, "GameObject Container invalid!");
	}

	for (const auto& emmiter : ref->emmiters) {
		AddEmmiter(emmiter.get());
	}

	startON = ref->startON;

	isON = startON;
	hasToEnd = false;
}

ParticleSystem::~ParticleSystem()
{
}

void ParticleSystem::Update(double dt)
{
	bool allEmmitersOFF = true;

	if (isON) {
		for (auto i = emmiters.begin(); i != emmiters.end(); ++i) {
			(*i)->Update(engine->dt);

			if ((*i)->isON) {
				allEmmitersOFF = false;
			}
		}

		if (allEmmitersOFF) {
			Stop();
		}
	}
}

void ParticleSystem::DrawComponent(Camera* camera)
{
	for (auto i = emmiters.begin(); i != emmiters.end(); ++i) {
		(*i)->Render(camera);
	}
}

void ParticleSystem::Play()
{
	isON = true;
	hasToEnd = false;
}

void ParticleSystem::Pause()
{
	isON = false;
}

void ParticleSystem::Replay()
{
	Play();
	for (auto i = emmiters.begin(); i != emmiters.end(); ++i) {
		(*i)->Start();
	}
	hasToEnd = false;
}

void ParticleSystem::Stop()
{
	Pause();
	for (auto i = emmiters.begin(); i != emmiters.end(); ++i) {
		(*i)->Start();
	}
}

void ParticleSystem::End()
{
	hasToEnd = true;
}

bool ParticleSystem::HasToEnd()
{
	return hasToEnd;
}

void ParticleSystem::ClearEmmiters()
{
	emmiters.clear();
}

Emmiter* ParticleSystem::AddEmmiter()
{
	auto e = std::make_unique<Emmiter>(this);
	emmiters.push_back(std::move(e));
	return emmiters[emmiters.size() - 1].get();
}

Emmiter* ParticleSystem::AddEmmiter(Emmiter* ref)
{
	auto e = std::make_unique<Emmiter>(this, ref);
	emmiters.push_back(std::move(e));
	return emmiters[emmiters.size() - 1].get();
}

json ParticleSystem::SaveComponent()
{
	json particleSystemJSON;

	if (!emmiters.empty())
	{
		json emmitersJSON;

		for (const auto& emmiter : emmiters)
		{
			emmitersJSON.push_back(emmiter.get()->SaveEmmiter());
		}
		particleSystemJSON["Emmiters"] = emmitersJSON;
	}

	particleSystemJSON["UID"] = UID;
	particleSystemJSON["Name"] = name;
	particleSystemJSON["Type"] = type;

	particleSystemJSON["StartON"] = startON;

	return particleSystemJSON;
}

void ParticleSystem::LoadComponent(const json& transformJSON)
{
	// Load basic properties
	if (transformJSON.contains("UID"))
	{
		UID = transformJSON["UID"];
	}

	if (transformJSON.contains("Name"))
	{
		name = transformJSON["Name"];
	}

	if (transformJSON.contains("Type"))
	{
		type = transformJSON["Type"];
	}

	if (transformJSON.contains("StartON"))
	{
		startON = transformJSON["StartON"];
		isON = startON;
	}

	ClearEmmiters();

	// load emmiters
	if (transformJSON.contains("Emmiters"))
	{
		const json& emmitersJSON = transformJSON["Emmiters"];

		for (const auto& emmiterJSON : emmitersJSON)
		{
			auto e = AddEmmiter();
			e->ClearModules();
			e->LoadEmmiter(emmiterJSON);
		}
	}

}

void ParticleSystem::ExportParticles()
{
	//Change to save the Scene Class
	name.shrink_to_fit();
	std::string fileNameExt = name;

	std::string finalName;

	for (int i = 0; fileNameExt.at(i) != '\0'; ++i) {
		finalName += fileNameExt.at(i);
	}

	name = finalName;

	finalName.append(".particles");

	fs::path filename = fs::path(ASSETS_PATH) / "Particles" / finalName;
	//string filename = "Assets/Scenes/";
	fs::path folderName = fs::path(ASSETS_PATH) / "Particles";
	fs::create_directories(folderName);

	json particlesJSON;

	particlesJSON = SaveComponent();

	std::ofstream(filename) << particlesJSON.dump(2);
	LOG(LogType::LOG_OK, "SAVE SUCCESFUL");
}

bool ParticleSystem::IsON()
{
	return isON;
}

Transform* ParticleSystem::GetTransform()
{
	return transform;
}`, 'cpp');

        // Editor 3
        createEditor('editor3', `#include "InitializeEmmiterModule.h"
#include "Emmiter.h"
#include "ParticleSystem.h"

// set speed ---------------------------------------------------------------------------------------------------
SetSpeed::SetSpeed(Emmiter* owner)
{
	type = SET_SPEED;
	this->owner = owner;

	speed.usingSingleValue = false;
	speed.rangeValue.lowerLimit = 1;
	speed.rangeValue.upperLimit = 2;
}

SetSpeed::SetSpeed(Emmiter* owner, SetSpeed* ref)
{
	type = SET_SPEED;
	this->owner = owner;

	speed = ref->speed;
}

void SetSpeed::Initialize(Particle* particle)
{
	if (speed.usingSingleValue) {
		particle->speed = speed.singleValue;
	}
	else {
		particle->speed = randomFloat(speed.rangeValue.lowerLimit, speed.rangeValue.upperLimit);
	}
}

json SetSpeed::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueSpeed"] = speed.usingSingleValue;
	moduleJSON["MinSpeed"] = speed.rangeValue.lowerLimit;
	moduleJSON["MaxSpeed"] = speed.rangeValue.upperLimit;

	return moduleJSON;
}

void SetSpeed::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueSpeed"))
	{
		speed.usingSingleValue = moduleJSON["UsingSingleValueSpeed"];
	}

	if (moduleJSON.contains("MinSpeed"))
	{
		speed.rangeValue.lowerLimit = moduleJSON["MinSpeed"];
	}

	if (moduleJSON.contains("MaxSpeed"))
	{
		speed.rangeValue.upperLimit = moduleJSON["MaxSpeed"];
	}
}

// set color ---------------------------------------------------------------------------------------------------
SetColor::SetColor(Emmiter* owner)
{
	type = SET_COLOR;
	this->owner = owner;

	color.usingSingleValue = true;
	color.rangeValue.lowerLimit = glm::vec4(0, 0, 0, 1);
	color.rangeValue.upperLimit = glm::vec4(1, 1, 1, 0);
}

SetColor::SetColor(Emmiter* owner, SetColor* ref)
{
	type = SET_COLOR;
	this->owner = owner;

	color = ref->color;
}

void SetColor::Initialize(Particle* particle)
{
	if (color.usingSingleValue) {
		particle->initialColor = color.singleValue;
	}
	else {
		glm::vec4 randomVec = glm::vec4{
			randomFloat(color.rangeValue.lowerLimit.r, color.rangeValue.upperLimit.r),
			randomFloat(color.rangeValue.lowerLimit.g, color.rangeValue.upperLimit.g),
			randomFloat(color.rangeValue.lowerLimit.b, color.rangeValue.upperLimit.b),
			randomFloat(color.rangeValue.lowerLimit.a, color.rangeValue.upperLimit.a),
		};

		particle->initialColor = randomVec;
	}

	particle->color = particle->initialColor;
}

json SetColor::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueColor"] = color.usingSingleValue;
	moduleJSON["MinColor"] = { color.rangeValue.lowerLimit.x, color.rangeValue.lowerLimit.y, color.rangeValue.lowerLimit.z, color.rangeValue.lowerLimit.a };
	moduleJSON["MaxColor"] = { color.rangeValue.upperLimit.x, color.rangeValue.upperLimit.y, color.rangeValue.upperLimit.z, color.rangeValue.upperLimit.a };

	return moduleJSON;
}

void SetColor::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueColor"))
	{
		color.usingSingleValue = moduleJSON["UsingSingleValueColor"];
	}

	if (moduleJSON.contains("MinColor"))
	{
		color.rangeValue.lowerLimit.x = moduleJSON["MinColor"][0];
		if (color.rangeValue.lowerLimit.x > 1)
			color.rangeValue.lowerLimit.x /= 255;
		color.rangeValue.lowerLimit.y = moduleJSON["MinColor"][1];
		if (color.rangeValue.lowerLimit.y > 1)
			color.rangeValue.lowerLimit.y /= 255;
		color.rangeValue.lowerLimit.z = moduleJSON["MinColor"][2];
		if (color.rangeValue.lowerLimit.z > 1)
			color.rangeValue.lowerLimit.z /= 255;
		color.rangeValue.lowerLimit.a = moduleJSON["MinColor"][3];
		if (color.rangeValue.lowerLimit.a > 1) 
			color.rangeValue.lowerLimit.a /= 255;
	}

	if (moduleJSON.contains("MaxColor"))
	{
		color.rangeValue.upperLimit.x = moduleJSON["MaxColor"][0];
		if (color.rangeValue.upperLimit.x > 1)
			color.rangeValue.upperLimit.x /= 255;
		color.rangeValue.upperLimit.y = moduleJSON["MaxColor"][1];
		if (color.rangeValue.upperLimit.y > 1)
			color.rangeValue.upperLimit.y /= 255;
		color.rangeValue.upperLimit.z = moduleJSON["MaxColor"][2];
		if (color.rangeValue.upperLimit.z > 1) 
			color.rangeValue.upperLimit.z /= 255;
		color.rangeValue.upperLimit.a = moduleJSON["MaxColor"][3];
		if (color.rangeValue.upperLimit.a > 1)
			color.rangeValue.upperLimit.a /= 255;
	}
}

// set scale ---------------------------------------------------------------------------------------------------
SetScale::SetScale(Emmiter* owner)
{
	type = SET_SCALE;
	this->owner = owner;

	scale.usingSingleValue = true;
	scale.rangeValue.lowerLimit = vec3(1, 1, 1);
	scale.rangeValue.upperLimit = vec3(2, 2, 2);

	isProportional = true;
}

SetScale::SetScale(Emmiter* owner, SetScale* ref)
{
	type = SET_SCALE;
	this->owner = owner;

	scale = ref->scale;
	isProportional = ref->isProportional;
}

void SetScale::Initialize(Particle* particle)
{
	if (scale.usingSingleValue) {
		if (isProportional) {
			particle->initialScale = vec3(scale.singleValue.x, scale.singleValue.x, scale.singleValue.x);
		}
		else {
			particle->initialScale = scale.singleValue;
		}
	}
	else {
		vec3 randomVec;
		if (isProportional) {
			auto value = randomFloat(scale.rangeValue.lowerLimit.x, scale.rangeValue.upperLimit.x);
			randomVec = vec3(value, value, value);
		}
		else {
			randomVec = vec3{
				randomFloat(scale.rangeValue.lowerLimit.x, scale.rangeValue.upperLimit.x),
				randomFloat(scale.rangeValue.lowerLimit.y, scale.rangeValue.upperLimit.y),
				randomFloat(scale.rangeValue.lowerLimit.z, scale.rangeValue.upperLimit.z) };
		}
		particle->initialScale = randomVec;
	}

	particle->scale = particle->initialScale;
}

json SetScale::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueScale"] = scale.usingSingleValue;
	moduleJSON["MinScale"] = { scale.rangeValue.lowerLimit.x, scale.rangeValue.lowerLimit.y, scale.rangeValue.lowerLimit.z };
	moduleJSON["MaxScale"] = { scale.rangeValue.upperLimit.x, scale.rangeValue.upperLimit.y, scale.rangeValue.upperLimit.z };

	moduleJSON["IsProportional"] = isProportional;

	return moduleJSON;
}

void SetScale::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueScale"))
	{
		scale.usingSingleValue = moduleJSON["UsingSingleValueScale"];
	}

	if (moduleJSON.contains("MinScale"))
	{
		scale.rangeValue.lowerLimit.x = moduleJSON["MinScale"][0];
		scale.rangeValue.lowerLimit.y = moduleJSON["MinScale"][1];
		scale.rangeValue.lowerLimit.z = moduleJSON["MinScale"][2];

	}

	if (moduleJSON.contains("MaxScale"))
	{
		scale.rangeValue.upperLimit.x = moduleJSON["MaxScale"][0];
		scale.rangeValue.upperLimit.y = moduleJSON["MaxScale"][1];
		scale.rangeValue.upperLimit.z = moduleJSON["MaxScale"][2];
	}

	if (moduleJSON.contains("IsProportional"))
	{
		isProportional = moduleJSON["IsProportional"];
	}
}

// set offset --------------------------------------------------------------------------------------
SetOffset::SetOffset(Emmiter* owner)
{
	type = SET_OFFSET;
	this->owner = owner;

	offset.usingSingleValue = true;
	offset.rangeValue.lowerLimit = vec3(0, 1, 0);
	offset.rangeValue.upperLimit = vec3(0, -1, 0);
}

SetOffset::SetOffset(Emmiter* owner, SetOffset* ref)
{
	type = SET_OFFSET;
	this->owner = owner;

	offset = ref->offset;
}

void SetOffset::Initialize(Particle* particle)
{
	if (offset.usingSingleValue) {
		particle->position += offset.singleValue;
	}
	else {
		vec3 randomVec = vec3{
			randomFloat(offset.rangeValue.lowerLimit.x, offset.rangeValue.upperLimit.x),
			randomFloat(offset.rangeValue.lowerLimit.y, offset.rangeValue.upperLimit.y),
			randomFloat(offset.rangeValue.lowerLimit.z, offset.rangeValue.upperLimit.z) };

		quat qTemp = owner->owner->GetContainerGO()->GetComponent<Transform>()->GetGlobalRotation();
		particle->position += randomVec * quat(-qTemp.x, qTemp.y, qTemp.z, qTemp.w);
	}
}

json SetOffset::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueOffset"] = offset.usingSingleValue;
	moduleJSON["MinOffset"] = { offset.rangeValue.lowerLimit.x, offset.rangeValue.lowerLimit.y, offset.rangeValue.lowerLimit.z };
	moduleJSON["MaxOffset"] = { offset.rangeValue.upperLimit.x, offset.rangeValue.upperLimit.y, offset.rangeValue.upperLimit.z };

	return moduleJSON;
}

void SetOffset::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueOffset"))
	{
		offset.usingSingleValue = moduleJSON["UsingSingleValueOffset"];
	}

	if (moduleJSON.contains("MinOffset"))
	{
		offset.rangeValue.lowerLimit.x = moduleJSON["MinOffset"][0];
		offset.rangeValue.lowerLimit.y = moduleJSON["MinOffset"][1];
		offset.rangeValue.lowerLimit.z = moduleJSON["MinOffset"][2];

	}

	if (moduleJSON.contains("MaxOffset"))
	{
		offset.rangeValue.upperLimit.x = moduleJSON["MaxOffset"][0];
		offset.rangeValue.upperLimit.y = moduleJSON["MaxOffset"][1];
		offset.rangeValue.upperLimit.z = moduleJSON["MaxOffset"][2];
	}
}

// set direction -----------------------------------------------------------------------------------
SetDirection::SetDirection(Emmiter* owner)
{
	type = SET_DIRECTION;
	this->owner = owner;

	direction.usingSingleValue = false;
	direction.rangeValue.lowerLimit = vec3(-0.5f, 1, -0.5f);
	direction.rangeValue.upperLimit = vec3(0.5f, 2, 0.5f);
}

SetDirection::SetDirection(Emmiter* owner, SetDirection* ref)
{
	type = SET_DIRECTION;
	this->owner = owner;

	direction = ref->direction;

}

void SetDirection::Initialize(Particle* particle)
{
	if (direction.usingSingleValue) {
		particle->direction = direction.singleValue;
	}
	else {
		vec3 randomVec = vec3{
			randomFloat(direction.rangeValue.lowerLimit.x, direction.rangeValue.upperLimit.x),
			randomFloat(direction.rangeValue.lowerLimit.y, direction.rangeValue.upperLimit.y),
			randomFloat(direction.rangeValue.lowerLimit.z, direction.rangeValue.upperLimit.z) };

		particle->direction = randomVec;
	}

	if (owner->isGlobal) {
		mat4 worldTransform = owner->owner->GetTransform()->GetGlobalTransform();

		glm::dmat3 worldRotation = worldTransform;
		
		particle->direction = worldRotation * particle->direction;
	}

	if(particle->direction != vec3())
		particle->direction = glm::normalize(particle->direction);
}

json SetDirection::SaveModule()
{
	json moduleJSON;

	moduleJSON["Type"] = type;

	moduleJSON["UsingSingleValueDirection"] = direction.usingSingleValue;
	moduleJSON["MinDirection"] = { direction.rangeValue.lowerLimit.x, direction.rangeValue.lowerLimit.y, direction.rangeValue.lowerLimit.z };
	moduleJSON["MaxDirection"] = { direction.rangeValue.upperLimit.x, direction.rangeValue.upperLimit.y, direction.rangeValue.upperLimit.z };

	return moduleJSON;
}

void SetDirection::LoadModule(const json& moduleJSON)
{
	if (moduleJSON.contains("Type"))
	{
		type = moduleJSON["Type"];
	}

	if (moduleJSON.contains("UsingSingleValueDirection"))
	{
		direction.usingSingleValue = moduleJSON["UsingSingleValueDirection"];
	}

	if (moduleJSON.contains("MinDirection"))
	{
		direction.rangeValue.lowerLimit.x = moduleJSON["MinDirection"][0];
		direction.rangeValue.lowerLimit.y = moduleJSON["MinDirection"][1];
		direction.rangeValue.lowerLimit.z = moduleJSON["MinDirection"][2];

	}

	if (moduleJSON.contains("MaxDirection"))
	{
		direction.rangeValue.upperLimit.x = moduleJSON["MaxDirection"][0];
		direction.rangeValue.upperLimit.y = moduleJSON["MaxDirection"][1];
		direction.rangeValue.upperLimit.z = moduleJSON["MaxDirection"][2];
	}
}`, 'cpp'); 

createEditor('editor4' ,`using System;
using System.Runtime.CompilerServices;

public struct Vector3
{
    public float x { get; }
    public float y { get; }
    public float z { get; }

    public static Vector3 zero      { get { return new Vector3(0, 0, 0); } }
    public static Vector3 right     { get { return new Vector3(1.0f, 0, 0); } }
    public static Vector3 up        { get { return new Vector3(0, 1.0f, 0); } }
    public static Vector3 forward   { get { return new Vector3(0, 0, 1.0f); } }

    public Vector3(float x, float y, float z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public static Vector3 operator +(Vector3 a, Vector3 b)
    {
        return new Vector3(a.x + b.x, a.y + b.y, a.z + b.z);
    }

    public static Vector3 operator -(Vector3 a, Vector3 b)
    {
        return new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }

    public static Vector3 operator *(Vector3 a, Vector3 b)
    {
        return new Vector3(a.x * b.x, a.y * b.y, a.z * b.z);
    }

    public static Vector3 operator *(Vector3 a, float b)
    {
        return new Vector3(a.x * b, a.y * b, a.z * b);
    }

    public static Vector3 operator /(Vector3 a, float b)
    {
        return new Vector3(a.x / b, a.y / b, a.z / b);
    }

    public static bool operator ==(Vector3 a, Vector3 b)
    {
        return a.x == b.x && a.y == b.y && a.z == b.z;
    }

    public static bool operator !=(Vector3 a, Vector3 b)
    {
        return a.x != b.x || a.y != b.y || a.z != b.z;
    }

    public float Magnitude()
    {
        return (float)Math.Sqrt(x * x + y * y + z * z);
    }

    public Vector3 Normalize()
    {
        float mag = Magnitude();

        if (mag == 0) { return Vector3.zero; }

        return new Vector3(x, y, z) / Magnitude();
    }

    public static float Distance(Vector3 a, Vector3 b)
    {
        Vector3 resultVector = a - b;

        return resultVector.Magnitude();
    }

    public static float Dot(Vector3 a, Vector3 b)
    {
        return  -(a.x * b.x + a.y * b.y + a.z * b.z);
    }
}
` , 'cpp'); }
// Wait for the window to fully load before initializing editors
window.onload = function() {
            initializeEditors();
            setTimeout(function() {
                document.querySelectorAll('.editor-container').forEach(container => {
                    const event = new Event('resize');
                    window.dispatchEvent(event);
                });
            }, 100);
        };
    });
</script>
